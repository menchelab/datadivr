<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Game Client</title>
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
      crossorigin=""
    />
    <style>
      body,
      html {
        margin: 0;
        padding: 0;
        height: 100%;
        width: 100%;
      }
      #map {
        height: 100vh;
        width: 100%;
      }
      .controls {
        position: absolute;
        top: 20px;
        right: 20px;
        z-index: 1000;

        background: rgba(255, 255, 255, 0.9);
        padding: 10px;
        border-radius: 4px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        min-width: 200px;
      }
      #nameInput {
        padding: 5px;
        margin-right: 10px;
      }
      #status {
        margin-top: 5px;
        font-size: 0.9em;
      }

      #status.connected {
        color: #2ecc71;
      }

      #status.disconnected {
        color: #e74c3c;
      }
      .arrow-marker {
        font-size: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
        transform-origin: center center;
      }
      .client-list {
        margin-top: 10px;
        font-size: 0.9em;
        max-height: 300px;
        overflow-y: auto;
      }
      .client-item {
        border-bottom: 1px solid #eee;
        padding: 5px 0;
      }
      .client-item:last-child {
        border-bottom: none;
      }
      .client-name {
        font-weight: bold;
      }
      .client-details {
        color: #666;
        font-family: monospace;
        font-size: 0.9em;
      }
    </style>
  </head>
  <body>
    <div class="controls">
      <input type="text" id="nameInput" placeholder="Enter your name" />
      <div id="status">Disconnected</div>
      <div class="client-list" id="clientList"></div>
    </div>

    <div id="map"></div>

    <script
      src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
      crossorigin=""
    ></script>
    <script src="https://cdn.jsdelivr.net/npm/leaflet.marker.slideto@0.2.0/Leaflet.Marker.SlideTo.js"></script>
    <script>
      (() => {
        const WS_URL = "ws://localhost:8765/ws";
        const DEFAULT_VIEW = [48.2082, 16.3738];
        const DEFAULT_ZOOM = 13;
        const CIRCLE_RADIUS = 100000; // 100 km
        // this is just a helper circle, the actually detection circle/calc is done serverside

        const SLIDE_DURATION = 100; // ms for position update animation

        let ws;
        let map;
        let myMarker;
        let myCircle;
        let markers = {};
        let currentDirection = 90;

        /**
         * Initialize the map with Leaflet.
         */
        const initMap = () => {
          map = L.map("map").setView(DEFAULT_VIEW, DEFAULT_ZOOM);
          L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
            maxZoom: 19,
          }).addTo(map);

          map.on("click", onMapClick);

          // if shift key is pressed, update the marker position and report to server continuously
          map.on("mousemove", (e) => {
            if (e.originalEvent.shiftKey) {
              updateMarkerPosition(e.latlng);
            }
          });
        };

        /**
         * Handle map click events, set marker and send position update to server
         * @param {Object} e - Leaflet event object.
         */
        const onMapClick = (e) => {
          updateMarkerPosition(e.latlng);
        };

        /**
         * Update the connection status display
         * @param {string} status - The status message to display
         */
        const updateStatus = (status) => {
          const statusElement = document.getElementById("status");
          if (statusElement) {
            statusElement.textContent = status;
            statusElement.className = status.toLowerCase(); // Will add either 'connected' or 'disconnected' class
          }
        };

        /**
         * Establish a WebSocket connection.
         */
        const connectWebSocket = () => {
          ws = new WebSocket(WS_URL);

          ws.onopen = () => {
            updateStatus("Connected");
          };

          ws.onclose = () => {
            updateStatus("Disconnected");
            setTimeout(connectWebSocket, 5000);
          };

          ws.onmessage = handleWebSocketMessage;
        };

        /**
         * Send a message through WebSocket.
         * @param {Object} message - The message object to send.
         */
        const sendMessage = (message) => {
          if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify(message));
          }
        };

        /**
         * Handle incoming WebSocket messages.
         * @param {MessageEvent} event - The message event.
         */
        const handleWebSocketMessage = (event) => {
          console.log("Raw WebSocket message:", event.data);
          try {
            const data = JSON.parse(event.data);
            if (data.event_name === "GAMESERVER_NEARBY_UPDATE") {
              updateNearbyClients(data.payload.nearby_clients);
            }
          } catch (error) {
            console.error("Error parsing WebSocket message:", error);
          }
        };

        /**
         * Set the player's name and send it to the server.
         */
        const setName = () => {
          const nameInput = document.getElementById("nameInput");
          const name = nameInput.value.trim();

          if (name) {
            const message = {
              event_name: "GAMESERVER_SET_NAME",
              to: "others",
              payload: {
                name: name,
              },
            };
            sendMessage(message);
          }
        };

        /**
         * Clear all existing markers from the map.
         */
        const clearMarkers = () => {
          Object.values(markers).forEach((marker) => map.removeLayer(marker));
          markers = {};
        };

        /**
         * Update nearby clients on the map.
         * @param {Array} clients - List of nearby clients.
         */
        const updateNearbyClients = (clients) => {
          // console.log("Updating nearby clients:", clients); // Debug incoming data

          const currentClientIds = new Set(
            clients.map((client) => client.client_id),
          );

          // Update client list
          const clientList = document.getElementById("clientList");
          clientList.innerHTML = clients
            .map((client) => {
              const { name, latitude, longitude, altitude, direction } = client;
              return `
                <div class="client-item">
                  <div class="client-name">${name || "Unknown"}</div>
                  <div class="client-details">
                    Lat: ${latitude?.toFixed(4) || "N/A"}<br>
                    Lng: ${longitude?.toFixed(4) || "N/A"}<br>
                    Alt: ${altitude || "N/A"}m<br>
                    Dir: ${direction?.toFixed(1) || "N/A"}Â°
                  </div>
                </div>
              `;
            })
            .join("");

          // Remove markers that are no longer in the nearby clients list
          Object.keys(markers).forEach((clientId) => {
            if (!currentClientIds.has(clientId)) {
              map.removeLayer(markers[clientId]);
              delete markers[clientId];
            }
          });

          clients.forEach((client) => {
            const { client_id, name, latitude, longitude, direction } = client;
            console.log(`Client ${name} direction: ${direction}`); // Debug direction value

            if (latitude && longitude && name) {
              if (markers[client_id]) {
                // Existing marker - animate to new position and rotation
                const marker = markers[client_id];
                marker.slideTo([latitude, longitude], {
                  duration: SLIDE_DURATION,
                  keepAtCenter: false,
                });

                // Update rotation immediately first
                const element = marker
                  .getElement()
                  ?.querySelector(".arrow-marker");
                if (element) {
                  element.style.transform = `rotate(${direction - 90}deg)`;
                }

                // Update tooltip
                marker.setTooltipContent(name);
              } else {
                // New marker - create with correct direction
                const marker = createArrowMarker(
                  [latitude, longitude],
                  direction,
                )
                  .bindTooltip(name, {
                    permanent: true,
                    direction: "right",
                    offset: [20, 0],
                    opacity: 0.7,
                  })
                  .addTo(map);
                markers[client_id] = marker;
              }
            }
          });
        };

        /**
         * Initialize event listeners.
         */
        const initEventListeners = () => {
          const nameInput = document.getElementById("nameInput");
          nameInput.addEventListener("keypress", (e) => {
            if (e.key === "Enter") {
              setName();
            }
          });
        };

        /**
         * Create an arrow marker with the specified direction
         * @param {Array} latlng - The [lat, lng] position
         * @param {number} direction - Direction in degrees
         * @param {boolean} isMyMarker - Whether this is the user's marker
         * @returns {L.Marker} - Leaflet marker
         */
        const createArrowMarker = (latlng, direction, isMyMarker = false) => {
          const size = isMyMarker ? 40 : 20;
          const fontSize = isMyMarker ? 40 : 20;
          const anchor = isMyMarker ? 20 : 10;

          const arrowIcon = L.divIcon({
            html: `<div class="arrow-marker" style="transform: rotate(${
              direction - 90
            }deg); font-size: ${fontSize}px;">â¤</div>`,
            className: "",
            iconSize: [size, size],
            iconAnchor: [anchor, anchor],
          });

          return L.marker(latlng, { icon: arrowIcon });
        };

        // Add function to calculate bearing between two points
        const calculateBearing = (startLat, startLng, destLat, destLng) => {
          startLat = (startLat * Math.PI) / 180;
          startLng = (startLng * Math.PI) / 180;
          destLat = (destLat * Math.PI) / 180;
          destLng = (destLng * Math.PI) / 180;

          const y = Math.sin(destLng - startLng) * Math.cos(destLat);
          const x =
            Math.cos(startLat) * Math.sin(destLat) -
            Math.sin(startLat) *
              Math.cos(destLat) *
              Math.cos(destLng - startLng);
          let bearing = (Math.atan2(y, x) * 180) / Math.PI;

          // Convert to 0-360 degrees
          bearing = (bearing + 360) % 360;
          return bearing;
        };

        // Update the marker position function to calculate direction
        const updateMarkerPosition = (latlng) => {
          const { lat, lng } = latlng;

          // Calculate new direction if we have a previous position
          if (myMarker) {
            const prevPos = myMarker.getLatLng();
            // Only update direction if we've moved a meaningful distance
            if (prevPos.lat !== lat || prevPos.lng !== lng) {
              currentDirection = calculateBearing(
                prevPos.lat,
                prevPos.lng,
                lat,
                lng,
              );

              // Update marker position and rotation
              myMarker.setLatLng([lat, lng]);
              const element = myMarker
                .getElement()
                ?.querySelector(".arrow-marker");
              if (element) {
                element.style.transform = `rotate(${currentDirection - 90}deg)`;
              }
            }
          } else {
            // Create new marker only if it doesn't exist
            myMarker = createArrowMarker(
              [lat, lng],
              currentDirection,
              true,
            ).addTo(map);
          }

          // Update or create circle
          if (myCircle) {
            myCircle.setLatLng([lat, lng]);
          } else {
            myCircle = L.circle([lat, lng], { radius: CIRCLE_RADIUS }).addTo(
              map,
            );
          }

          const message = {
            event_name: "GAMESERVER_INFO_UPDATE",
            to: "others",
            payload: {
              latitude: lat,
              longitude: lng,
              altitude: 500,
              direction: currentDirection,
            },
          };

          sendMessage(message);
        };

        /**
         * Initialize the application.
         */
        const init = () => {
          initMap();
          connectWebSocket();
          initEventListeners();
        };

        window.onload = init;
      })();
    </script>
  </body>
</html>
