<!--
    Must be ES10 compatible because old chromium in unreal.
    eg. no use of optional chaining, etc
-->
<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Game Client</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />
  <style>
    body,
    html {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
    }

    #map {
      height: 100vh;
      width: 100%;
    }

    .controls {
      position: absolute;
      top: 20px;
      right: 20px;
      z-index: 1000;

      background: rgba(255, 255, 255, 0.7);
      padding: 10px;
      border-radius: 4px;
      font-family: Arial, sans-serif;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      min-width: 200px;
    }

    #nameInput {
      padding: 5px;
      margin-right: 10px;
    }

    #status {
      margin-top: 5px;
      font-size: 0.9em;
    }

    #status.connected {
      color: #2ecc71;
    }

    #status.disconnected {
      color: #e74c3c;
    }

    .arrow-marker {
      font-size: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      transform-origin: center center;
    }

    .client-list {
      margin-top: 10px;
      font-size: 0.9em;
      max-height: 85vh;
      overflow-y: auto;
    }

    .client-item {
      display: flex;
      flex-direction: column;
      border-bottom: 1px solid #eee;
      padding: 5px 0;
    }

    .client-item:last-child {
      border-bottom: none;
    }

    .client-name {
      font-weight: bold;
      margin-bottom: 5px;
    }

    .client-details {
      display: flex;
      justify-content: space-between;
      width: 100%;
      color: #666;
      font-family: monospace;
      font-size: 0.9em;
    }

    .client-details div {
      flex: 1;
    }


    h3 {
      text-align: center;
      font-family: "arial";
      font-weight: lighter;
      font-size: 16px;
      border: 0px;
      width: 100%;
      margin: 0px;
      padding: 0px;
      user-select: none;
    }



    h4 {
      text-align: center;
      font-family: "arial";
      font-weight: lighter;
      font-size: 10px;
      border: 0px;
      width: 100%;
      margin: 0px;
      padding: 0px;
      user-select: none;
    }

    h1 {
      text-align: center;
      font-family: "arial";
      font-weight: lighter;
      font-size: 20px;
      border: 0px;
      width: 100%;
      margin: 0px;
      padding: 0px;
      user-select: none;

      background: #0099ff00;
    }

    .column {
      float: left;
      background: #a4dbff00;
      width: 25%;


      position: relative;
      z-index: 1000;
    }


    /* Clear floats after the columns */
    .row {
      position: absolute;

    }

    .row:after {

      content: "";
      display: table;
      clear: both;
    }

    .box {
      background-color: #a6ceea8f;
      border-radius: 4px;
      padding: 10px;
      margin: 10px;
      font-family: "arial";
    }
  </style>
</head>

<body>
  <div class="row">
    <div class="column">
      <div class="box" style="background:rgba(255, 255, 255, 0.537);">
        <h1 id="demo"></h1>
        <p id="description"></p>
        or select a takeoff location and press

      </div>
    </div>
    <div class="column">
      <div class="box" style="background:rgba(255, 255, 255, 0.537);">
        <h1 id="airspaceInfo">AIRSPACE INFO</h1>
      </div>
    </div>
    <div class="column" style="visibility: hidden;">FREE

    </div>
    <div class="column">
      <div class="box" style=" height:45px; background:rgba(255, 255, 255, 0.537);"">
        <div class=" row">
        <div class="column">
          <button id="joinRace" type="button" style="height:40px; width:70px; margin:5px;">LIVE<br>RACE</button>
        </div>
        <div class="column">
          <button id="histRace" type="button" style="height:40px; width:70px; margin:5px;">RE<br>RACE</button>
        </div>
        <div class="column">
          <button id="setStart" type="button" style="height:40px; width:70px; margin:5px;">SET<br>START</button>
        </div>
        <div class="column">
          <button id="setFly" type="button" style="height:40px; width:70px; margin:5px;; ">GO<br>FLY!</button>
        </div>
      </div>


    </div>

    <select id="taskSelect" style="width:100%; border:10px;"></select>
    <div class="box" style="background:rgba(255, 255, 255, 0.537);">
      <H1 id="nameInput">name</H1>
      
      <div id="status">Disconnected</div>
      <div class="client-list" id="clientList"></div>
    </div>
  </div>
  </div>

  <div style="position:absolute ;transform:translate(6px, 240px);"><img id="wind"
      src="{{ url_for('static', path='/images/wind.png') }}"></div>
  <div id="map" style="position:absolute; "></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
  <script src="https://cdn.jsdelivr.net/npm/leaflet.marker.slideto@0.2.0/Leaflet.Marker.SlideTo.js"></script>
  <script src="{{ url_for('static', path='/sectors.js') }}"></script>
  <script src="{{ url_for('static', path='/airspace.js') }}"></script>
  <script>
    function getCookie(name) {
        function escape(s) { return s.replace(/([.*+?\^$(){}|\[\]\/\\])/g, '\\$1'); }
        var match = document.cookie.match(RegExp('(?:^|;\\s*)' + escape(name) + '=([^;]*)'));
        return match ? match[1] : null;
    }
    
    var username = getCookie("name");
    var pw = getCookie("pw");

    var cycounter = 0;
    var cylinders = [];
    var cylabels = [];
    var lines = [];
    var thisline = [];
    var taskCylinder = [];
    var task = {};
    var playerpos = {
      lat: 47.23807715727137,
      long: 12.722411017577421,
      alt: 3000,
      rot_x: 0.5,
      rot_y: 0.5,
      rot_z: 180,
      type: 1,
      anim: 0,
    };


    "object" != typeof ue || "object" != typeof ue.interface ? ("object" != typeof ue && (ue = {}), ue.interface = {}, ue.interface.broadcast = function (e, t) {
      if ("string" == typeof e) {
        var o = [e, ""];
        void 0 !== t && (o[1] = t);
        var n = encodeURIComponent(JSON.stringify(o));
        "object" == typeof history && "function" == typeof history.pushState ? (history.pushState({}, "", "#" + n), history.pushState({}, "", "#" + encodeURIComponent("[]"))) : (document.location.hash = n, document.location.hash = encodeURIComponent("[]"))
      }
    }) : function (e) {
      ue.interface = {},
        ue.interface.broadcast = function (t, o) {
          "string" == typeof t && (void 0 !== o ? e.broadcast(t, JSON.stringify(o)) : e.broadcast(t, ""))
        }
    }


      (ue.interface), (ue4 = ue.interface.broadcast);



    // Constants
    const CONFIG = {
      WS_URL: "ws://localhost:8765/ws",
      MAP: {
        DEFAULT_VIEW: [48.2082, 16.3738],
        DEFAULT_ZOOM: 13,
        CIRCLE_RADIUS: 100000, // 100 km
        SLIDE_DURATION: 1000, // ms for position update animation
      },
    };

    var takeoff = null;
    // State
    const state = {
      ws: null,
      map: null,
      myMarker: null,
      myCircle: null,
      markers: {},
      rot_z: 90,
      alt: 2000,
    };
    ue.interface.playerupdate = function (data) {
      //update playerpos variable
      console.log(data);
      playerpos = JSON.parse(data);
      Markers.updatePosition();
      //populateTasklist(x["tasks"]);
    };
    // WebSocket handlers
    const WSClient = {
      connect() {
        state.ws = new window.WebSocket(CONFIG.WS_URL);
        state.ws.onopen = () => UI.updateStatus("Connected");
        state.ws.onclose = () => {
          UI.updateStatus("Disconnected");
          // Reset state of other clients, we can keep our own state
          state.markers = {};
          setTimeout(WSClient.connect, 5000);
        };
        state.ws.onmessage = this.handleMessage;
      },

      handleMessage(event) {
        try {
          const data = JSON.parse(event.data);

          if (data.event_name === "GAMESERVER_NEARBY_UPDATE") {
            Markers.updateNearbyClients(data.payload.nearby_clients);
            //console.log("Nearby clients updated:", data.payload);
            ue4("playerupdate", data.payload);
          }
          if (data.event_name === "TASK") {

            console.log("task received:", data.payload);
            task = data.payload;
            Map.deleteCylinders();
            var count = 0;
            for (var x = 0; x < data.payload["cylinder"].length; x++) {
              Map.makeCylinder({ "lat": data.payload["cylinder"][x]["lat"], "lng": data.payload["cylinder"][x]["lon"] }, data.payload["cylinder"][x]["rad"], count);
              count++;
            }
            Map.setView(data.payload["tofflat"], data.payload["tofflon"], 10);
            Markers.updatePosition({ "lat": data.payload["tofflat"], "lng": data.payload["tofflon"] });
            document.getElementById("description").innerHTML = data.payload["description"];
            takeoff.setLatLng({ "lat": data.payload["tofflat"], "lng": data.payload["tofflon"] });
            UI.setName();
          }
          if (data.event_name === "TASKLIST") {

            console.log("tasklist received:", data.payload);
            var select = document.getElementById("taskSelect");
            for (let i = data.payload["tasks"].length - 1; i >= 0; i--) {


              var opt = document.createElement("option");
              opt.value = data.payload["tasks"][i];
              opt.textContent = data.payload["tasks"][i];
              console.log(data.payload["tasks"][i]);
              select.appendChild(opt);
            }
          }
          if (data.event_name === "get_task_result") {

            console.log("task received:", data.payload);

          }
        } catch (error) {
          console.error("Error parsing WebSocket message:", error);
        }
      },

      send(message) {
        if (state.ws && state.ws.readyState === window.WebSocket.OPEN) {
          state.ws.send(JSON.stringify(message));
        }
      },
    };

    // UI handlers
    const UI = {
      updateStatus(status) {
        const statusElement = document.getElementById("status");
        if (statusElement) {
          statusElement.textContent = status;
          statusElement.className = status.toLowerCase();
        }
      },

      setName() {
        const nameInput = document.getElementById("nameInput");
        nameInput.innerHTML = username
        name = username
        if (username) {
          WSClient.send({
            event_name: "GAMESERVER_CLIENT_SETNAME",
            to: "others",
            payload: { name },
          });
        }
      },

      setFly() {
        ue4("fly", task);
        console.log(task);
      },
      setStartPoint() {
        console.log("set start point");
        takeoff.setLatLng(state.myMarker.getLatLng());
        task["tofflat"] = state.myMarker.getLatLng().lat;
        task["tofflon"] = state.myMarker.getLatLng().lng;
      },

      initEventListeners() {


        const setStartButton = document.getElementById("setStart");
        setStartButton.addEventListener("click", () => {
          this.setStartPoint();
        });

        const setFlyButton = document.getElementById("setFly");
        setFlyButton.addEventListener("click", () => {
          this.setFly();
        });

        const taskDD = document.getElementById("taskSelect");
        taskDD.addEventListener("change", () => {
          //this.setFly();
          console.log(taskDD.value);
          WSClient.send({
            event_name: "get_task",
            to: "server",
            payload: { "name": taskDD.value },
          });
        });
      },
    };


    var style1 = {
      strokewidth: 1,
      opacity: 1,
      color: "#0000ff",
      weight: 1
    };


    var style2 = {
      strokewidth: 1,
      opacity: 0.2,
      color: "#ff0000",
      weight: 1
    };
    // Map handlers
    const Map = {
      init() {
        state.map = L.map('map', {
          maxZoom: 20,
          minZoom: 6,
          zoomControl: false
        });
        state.map.setView(
          CONFIG.MAP.DEFAULT_VIEW,
          CONFIG.MAP.DEFAULT_ZOOM,
        );
        L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
          maxZoom: 19,
        }).addTo(state.map);
        /*
                  L.geoJSON(sectors["features"], {
                    onEachFeature: function (feature, layer) {
                      layer.bindTooltip(feature.name, { permanent: true, offset: [0, 0] });
                    },
                    style: { color: "#00ff00", fillOpacity: 0.0, stroke: "black", strokewidth: 1 }
        
                  },).addTo(state.map);
        */

        var airspacelayer1 = L.geoJSON(airspaceCTR["features"], style2).addTo(state.map);

        var airspacelayer = L.geoJSON(airspaceLines["features"], style1).addTo(state.map);
        const WindsockIcon = L.icon({
          iconUrl: 'static/images/Windsack.png',
          shadowUrl: 'static/images/plane_shadow.png',
          iconSize: [58, 39], // size of the icon
          shadowSize: [64, 64], // size of the shadow
          iconAnchor: [29, 39], // point of the icon which will correspond to marker's location
          shadowAnchor: [32, 32],  // the same for the shadow
          popupAnchor: [-3, -76] // point from which the popup should open relative to the iconAnchor
        });
        takeoff = L.marker({ "lat": 47.34077696378628, "lng": 13.096790697929256 }, { icon: WindsockIcon }).addTo(state.map)
        new L.Control.Zoom({ position: 'bottomleft' }).addTo(state.map);
        state.map.on("click", this.onClick);
        state.map.on("mousemove", this.onMouseMove);
      },

      onClick(e) {
        var target = e.latlng;
        playerpos.lat = target["lat"];
        playerpos.long = target["lng"];
        Markers.updatePosition();

        var testcoords = { "lat": target["lat"], "lon": target["lng"], "alt": 2000 };
        document.getElementById("airspaceInfo").innerHTML = checkAirSpace(testcoords);
        console.log(checkAirSpace(testcoords));
      },

      onMouseMove(e) {
        if (e.originalEvent.shiftKey) {

          playerpos = { "lat": e.latlng["lat"], "long": e.latlng["lng"] };
        }
      },

      setView(lat, lng, zoom) {
        state.map.setView([lat, lng], zoom);
      },

      deleteCylinders() {
        for (var i = 0; i < cylinders.length; i++) {
          cylinders[i].remove();
          cylabels[i].remove();

        };

        for (var i = 0; i < lines.length; i++) {
          lines[i].remove();

        };
        lines = [];
        thisline = [];
        taskCylinder = [];
        cycounter = 0;
        cylinders = [];
        cylabels = [];
      },

      makeCylinder(taskcoords, radius, i) {



        //for (let i = 0; i < tasks["tasks"][0]["cylinder"].length; i++) {

        var cylinder = new L.circle(taskcoords, parseInt(radius));
        thisline.push(taskcoords);
        cylinders.push(cylinder);
        var style = { fillColor: "#0000ff", fillOpacity: 0.2, color: "#0000FF" };
        cylinder.setStyle(style)
        cylinder.addTo(state.map);

        var tcy = { "lat": taskcoords["lat"], "lon": taskcoords["lng"], "rad": parseInt(radius) }
        taskCylinder.push(tcy);
        var ttext = "START";
        console.log(i)
        if (i > 0) {
          ttext = i;
          //console.log(cycounter);
          var pointA = [thisline[i]["lat"], thisline[i]["lng"]];
          var pointB = [thisline[i - 1]["lat"], thisline[i - 1]["lng"]];
          var pointList = [pointA, pointB];
          //console.log( thisline[cycounter-1]);
          var tline = L.polyline(pointList).addTo(state.map);
          lines.push(tline);
        }

        var myIcon = L.divIcon({ className: 'my-div-icon', html: ttext });
        // you can set .my-div-icon styles in CSS
        var thislabel = L.marker(taskcoords, { icon: myIcon }).addTo(state.map);
        cylabels.push(thislabel);

      },




      calculateBearing(startLat, startLng, destLat, destLng) {
        startLat = (startLat * Math.PI) / 180;
        startLng = (startLng * Math.PI) / 180;
        destLat = (destLat * Math.PI) / 180;
        destLng = (destLng * Math.PI) / 180;

        const y = Math.sin(destLng - startLng) * Math.cos(destLat);
        const x =
          Math.cos(startLat) * Math.sin(destLat) -
          Math.sin(startLat) *
          Math.cos(destLat) *
          Math.cos(destLng - startLng);
        let bearing = (Math.atan2(y, x) * 180) / Math.PI;
        return (bearing + 360) % 360;
      },
    };

    // Marker handlers
    const Markers = {





      createArrowMarker(latlng, rot_z, isMyMarker = false) {
        const size = isMyMarker ? 40 : 20;
        const fontSize = isMyMarker ? 40 : 20;
        const anchor = isMyMarker ? 20 : 10;

        const arrowIcon = L.divIcon({
          html: `<div class="arrow-marker" style="transform: rotate(${rot_z - 90
            }deg); font-size: ${fontSize}px;">➤</div>`,
          className: "",
          iconSize: [size, size],
          iconAnchor: [anchor, anchor],
        });

        return L.marker(latlng, { icon: arrowIcon });
      },

      updatePosition() {
        //const { lat, lng } = playerpos.lat, playerpos.long ;
        const lat = playerpos.lat;
        const lng = playerpos.long;
        if (state.myMarker) {


          state.myMarker.setLatLng([lat, lng]);
          //state.rot_z = playerpos.rot_z;
          //state.alt = playerpos.alt;
          const element = state.myMarker.getElement();
          if (element) {
            const arrowMarker = element.querySelector(".arrow-marker");
            if (arrowMarker) {
              arrowMarker.style.transform = `rotate(${playerpos.rot_z - 90}deg)`;
            }
          }

        } else {
          state.myMarker = this.createArrowMarker(
            [lat, lng],
            playerpos.rot_z - 90,
            true,
          ).addTo(state.map);
        }
        /*
                  if (state.myCircle) {
                    state.myCircle.setLatLng([lat, lng]);
                  } else {
                    state.myCircle = L.circle([lat, lng], {
                      radius: CONFIG.MAP.CIRCLE_RADIUS,
                    }).addTo(state.map);
                  }
        */
        WSClient.send({
          event_name: "GAMESERVER_CLIENT_UPDATE_STATE",
          to: "others",
          payload: playerpos,
        });
      },

      updateNearbyClients(clients) {
        const currentClientIds = new Set(
          clients.map((client) => client.client_id),
        );

        // Update client list UI
        const clientList = document.getElementById("clientList");
        clientList.innerHTML = clients
          .map((client) => {
            const {
              name,
              lat,
              long,
              alt,
              rot_x,
              rot_y,
              rot_z,
              type,
              anim,
            } = client;

            // Determine the emoticon based on the type
            let emoticon = "";
            switch (type) {
              case 0:
                emoticon = "🪂";
                break;
              case 1:
                emoticon = "🛩️";
                break;
              case 2:
                emoticon = "🐲";
                break;
              case 3:
                emoticon = "🕊️";
                break;
              default:
                emoticon = "";
            }

            return `
                  <div class="client-item">
                    <div class="client-name">${emoticon} ${name || "Unknown"
              } ${anim}</div>
                    <div class="client-details">
                      <div>
                        Lat/Lng:<br>
                        Alt:<br>
                        Rot:
                      </div>
                      <div>
                        ${lat !== undefined && long !== undefined
                ? `${lat.toFixed(4)}/${long.toFixed(4)}<br>`
                : "N/A/N/A<br>"
              }
                        ${alt || "N/A"}m<br>
                        ${rot_x !== undefined ? rot_x.toFixed(2) : "N/A"}/${rot_y !== undefined ? rot_y.toFixed(2) : "N/A"
              }/${rot_z !== undefined ? rot_z.toFixed(2) : "N/A"}
                      </div>
                    </div>
                  </div>
                `;
          })
          .join("");

        // Remove old markers
        Object.keys(state.markers).forEach((clientId) => {
          if (!currentClientIds.has(clientId)) {
            state.map.removeLayer(state.markers[clientId]);
            delete state.markers[clientId];
          }
        });

        // Update markers
        clients.forEach((client) => {
          const { client_id, name, lat, long, rot_z } = client;
          if (lat && long && name) {
            if (state.markers[client_id]) {
              const marker = state.markers[client_id];
              marker.slideTo([lat, long], {
                duration: CONFIG.MAP.SLIDE_DURATION,
                keepAtCenter: false,
              });

              const element = marker.getElement();
              if (element) {
                const arrowMarker = element.querySelector(".arrow-marker");
                if (arrowMarker) {
                  arrowMarker.style.transform = `rotate(${rot_z - 90}deg)`;
                }
              }
              marker.setTooltipContent(name);
            } else {
              state.markers[client_id] = this.createArrowMarker(
                [lat, long],
                rot_z,
              )
                .bindTooltip(name, {
                  permanent: true,
                  direction: "right",
                  offset: [20, 0],
                  opacity: 0.7,
                })
                .addTo(state.map);
            }
          }
        });
      },
    };

    // Initialize application
    window.onload = () => {
      let useragentstr = navigator.userAgent;
      let isue4 = useragentstr.includes("UnrealEngine");
      Map.init();
      WSClient.connect();
      UI.initEventListeners();
      
    };

  </script>

  <script>
    // Set the date we're counting down to
    var countDownDate = new Date("08/22/2027 15:37:25").getTime();

    // Update the count down every 1 second
    var x = setInterval(function () {

      // Get today's date and time
      var now = new Date().getTime();

      // Find the distance between now and the count down date
      var distance = countDownDate - now;

      // Time calculations for days, hours, minutes and seconds
      var days = Math.floor(distance / (1000 * 60 * 60 * 24));
      var hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
      var minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
      var seconds = Math.floor((distance % (1000 * 60)) / 1000);

      // Display the result in the element with id="demo"
      document.getElementById("demo").innerHTML = "LIVE RACE STARTS IN <br>" + hours + "h "
        + minutes + "m " + seconds + "s ";

      // If the count down is finished, write some text
      if (distance < 0) {
        clearInterval(x);
        document.getElementById("demo").innerHTML = "EXPIRED";
      }
    }, 1000);
  </script>
</body>

</html>