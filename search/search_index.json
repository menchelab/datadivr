{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"datadivr","text":"<p>A toolset for managing network graph projects with real-time server functionalities for multiple VR clients.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<ol> <li>Install using uv (recommended):</li> </ol> <pre><code>curl -LsSf https://astral.sh/uv/install.sh | sh\nuv pip install datadivr\n</code></pre>"},{"location":"cli/","title":"Command Line Interface","text":"<p>To see a list of available commands and options, run:</p> <pre><code>uv run datadivr --help\n</code></pre> <p>or</p> <pre><code>python -m datadivr --help\n</code></pre>"},{"location":"cli/#basic-commands","title":"Basic Commands","text":""},{"location":"cli/#start-server","title":"Start Server","text":"<pre><code>uv run datadivr start-server [--port PORT] [--host HOST]\n</code></pre> <p>Options:</p> <ul> <li><code>--port</code>: Port number (default: 8765)</li> <li><code>--host</code>: Host address (default: 127.0.0.1)</li> </ul> <p>(use 0.0.0.0 for host to bind to all interfaces)</p>"},{"location":"cli/#start-client","title":"Start Client","text":"<pre><code>uv run datadivr start-client [--port PORT] [--host HOST]\n</code></pre> <p>This interactive command line client is useful for testing and debugging, sending custom messages etc.</p>"},{"location":"cli/#client-input-format","title":"Client Input Format","text":"<p>The client accepts JSON messages in this format:</p> <pre><code>{\n  \"event_name\": \"sum_event\",\n  \"payload\": { \"numbers\": [1, 2, 3] },\n  \"to\": \"all\"\n}\n</code></pre> <p>Common event types:</p> <ul> <li><code>sum_event</code>: Calculate sum of numbers</li> <li><code>msg</code>: Send text message</li> </ul>"},{"location":"contributing/","title":"Contributing to <code>datadivr</code>","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/menchelab/datadivr/issues</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement a fix for it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>datadivr could always use more documentation, whether as part of the official docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/menchelab/datadivr/issues.</p> <p>If you are proposing a new feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions   are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up <code>datadivr</code> for local development. Please note this documentation assumes you already have <code>uv</code> and <code>Git</code> installed and ready to go.</p> <p>1. Fork the <code>datadivr</code> repo on GitHub.</p> <p>2. Clone your fork locally:</p> <pre><code>cd &lt;directory_in_which_repo_should_be_created&gt;\ngit clone git@github.com:menchelab/datadivr.git\n</code></pre> <p>3. Now we need to install the environment. Navigate into the directory</p> <pre><code>cd datadivr\n</code></pre> <p>Then, install and activate the environment with:</p> <pre><code>uv sync\n</code></pre> <p>4. Install pre-commit to run linters/formatters at commit time:</p> <pre><code>uv run pre-commit install\n</code></pre> <p>5. Create a branch for local development:</p> <pre><code>git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>6. Alternatively you can use vscode devcontainer feature which only requires you to have vscode and docker desktop installed, when you open the project in vscode install the extension and click the reopen in container button</p> <p>Now you can make your changes locally.</p> <p>6. Don't forget to add test cases for your added functionality to the <code>tests</code> directory.</p> <p>7. When you're done making changes, check that your changes pass the formatting tests.</p> <pre><code>make check\n</code></pre> <p>Now, validate that all unit tests are passing:</p> <pre><code>make test\n</code></pre> <p>9. Before raising a pull request you should also run tox. This will run the tests across different versions of Python:</p> <pre><code>uv run tox\n</code></pre> <p>10. Commit your changes and push your branch to GitHub:</p> <pre><code>git add .\ngit commit -m \"Your detailed description of your changes.\"\ngit push origin name-of-your-bugfix-or-feature\n</code></pre> <p>When writing commit messages, please follow the Conventional Commits specification. This helps maintain a standardized commit history and enables automated tooling. The basic format is:</p> <pre><code>&lt;type&gt;[optional scope]: &lt;description&gt;\n\n[optional body]\n\n[optional footer(s)]\n</code></pre> <p>Common types include:</p> <ul> <li><code>feat</code>: A new feature</li> <li><code>fix</code>: A bug fix</li> <li><code>docs</code>: Documentation changes</li> <li><code>style</code>: Code style changes (formatting, etc.)</li> <li><code>refactor</code>: Code changes that neither fix bugs nor add features</li> <li><code>test</code>: Adding or modifying tests</li> <li><code>chore</code>: Changes to build process or auxiliary tools</li> </ul> <p>Example commit messages:</p> <pre><code>feat(api): add new data validation endpoint\nfix: correct memory leak in processing loop\ndocs: update installation instructions\n</code></pre> <p>11. Submit a pull request through the GitHub website.</p>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <p>1. The pull request should include tests.</p> <p>2. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring.</p>"},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#websocket-server-example","title":"WebSocket Server Example","text":"<p>Start a WebSocket server using the CLI:</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#using-uv-recommended","title":"Using uv (Recommended)","text":"<pre><code># Install uv\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n\n# Install datadivr\nuv pip install datadivr\n</code></pre>"},{"location":"installation/#running-without-installation","title":"Running Without Installation","text":"<p>You can run datadivr directly without installing using <code>uvx</code>:</p> <pre><code>git clone https://github.com/menchelab/datadivr.git\ncd datadivr\n</code></pre>"},{"location":"installation/#development","title":"Development","text":"<p>For information about setting up a development environment, running tests, and contributing to the project, please see our Contributing Guide.</p>"},{"location":"installation/#verifying-installation","title":"Verifying Installation","text":"<pre><code># If installed\nuv run datadivr --help\n\n# Or without installing\nuvx datadivr --help\n</code></pre>"},{"location":"technical_overview/","title":"Technical Overview","text":"<p>This page documents all technologies, design patterns, tools, and practices used in datadivr.</p>"},{"location":"technical_overview/#core-technologies","title":"Core Technologies","text":""},{"location":"technical_overview/#websocket","title":"WebSocket","text":"<ul> <li>What: Full-duplex communication protocol over TCP</li> <li>Usage: Primary communication protocol for real-time data exchange</li> <li>Libraries:</li> <li><code>websockets</code> (client-side)</li> <li><code>fastapi</code> (server-side)</li> <li>Learn More</li> </ul>"},{"location":"technical_overview/#fastapi","title":"FastAPI","text":"<ul> <li>What: Modern, fast web framework for building APIs with Python</li> <li>Version: \u22650.115.4</li> <li>Usage: Powers the WebSocket server implementation</li> <li>Benefits:</li> <li>Automatic OpenAPI docs</li> <li>Native async support</li> <li>Built-in WebSocket support</li> <li>Type checking integration</li> <li>Learn More</li> </ul>"},{"location":"technical_overview/#pydantic","title":"Pydantic","text":"<ul> <li>What: Data validation using Python type annotations</li> <li>Version: \u22652.0.0</li> <li>Usage: Message validation and serialization</li> <li>Benefits:</li> <li>Automatic validation</li> <li>JSON serialization</li> <li>OpenAPI schema generation</li> <li>Type hints integration</li> <li>Learn More</li> </ul>"},{"location":"technical_overview/#development-tools","title":"Development Tools","text":""},{"location":"technical_overview/#uv","title":"uv","text":"<ul> <li>What: Modern Python package installer and resolver</li> <li>Usage: Primary package management and virtual environment tool</li> <li>Benefits:</li> <li>Faster than pip</li> <li>Better dependency resolution</li> <li>Built-in virtual environment management</li> <li>Compatible with pip requirements</li> <li>Learn More</li> </ul>"},{"location":"technical_overview/#pre-commit","title":"pre-commit","text":"<ul> <li>What: Git hook framework</li> <li>Version: \u22652.20.0</li> <li>Usage: Automated code quality checks before commits</li> <li>Hooks:</li> <li>Ruff (linting and formatting)</li> <li>mypy (type checking)</li> <li>YAML/TOML validation</li> <li>Trailing whitespace removal</li> <li>Merge conflict checks</li> <li>Prettier (markdown/yaml formatting)</li> <li>Learn More</li> </ul>"},{"location":"technical_overview/#ruff","title":"Ruff","text":"<ul> <li>What: Fast Python linter and formatter</li> <li>Version: \u22650.6.9</li> <li>Configuration:</li> <li>Target Python: 3.9+</li> <li>Line length: 120</li> <li>Enabled rule sets:<ul> <li>flake8-2020 (YTT)</li> <li>flake8-bandit (S)</li> <li>flake8-bugbear (B)</li> <li>flake8-builtins (A)</li> <li>flake8-comprehensions (C4)</li> <li>flake8-debugger (T10)</li> <li>flake8-simplify (SIM)</li> <li>isort (I)</li> <li>mccabe (C90)</li> <li>pycodestyle (E, W)</li> <li>pyflakes (F)</li> <li>pygrep-hooks (PGH)</li> <li>pyupgrade (UP)</li> <li>tryceratops (TRY)</li> </ul> </li> <li>Learn More</li> </ul>"},{"location":"technical_overview/#mypy","title":"mypy","text":"<ul> <li>What: Static type checker for Python</li> <li>Version: \u22650.991</li> <li>Configuration:</li> <li>Strict mode enabled</li> <li>Disallow untyped definitions</li> <li>No implicit optional</li> <li>Warn on unused ignores</li> <li>Show error codes</li> <li>Learn More</li> </ul>"},{"location":"technical_overview/#testing-tools","title":"Testing Tools","text":""},{"location":"technical_overview/#pytest","title":"pytest","text":"<ul> <li>What: Python testing framework</li> <li>Version: \u22657.2.0</li> <li>Features:</li> <li>Fixtures</li> <li>Parameterization</li> <li>Async support</li> <li>Coverage reporting</li> <li>Plugins:</li> <li>pytest-cov (\u22654.0.0)</li> <li>pytest-asyncio (\u22650.24.0)</li> <li>Learn More</li> </ul>"},{"location":"technical_overview/#tox","title":"tox","text":"<ul> <li>What: Test automation and virtual environment management</li> <li>Version: tox-uv \u22651.11.3</li> <li>Configuration:</li> <li>Python versions: 3.9-3.13</li> <li>Runs pytest with coverage</li> <li>Runs mypy type checking</li> <li>GitHub Actions integration</li> <li>Learn More</li> </ul>"},{"location":"technical_overview/#coveragepy","title":"Coverage.py","text":"<ul> <li>What: Code coverage measurement</li> <li>Usage: Track test coverage metrics</li> <li>Configuration:</li> <li>Branch coverage enabled</li> <li>Skip empty files</li> <li>Source package: datadivr</li> <li>Learn More</li> </ul>"},{"location":"technical_overview/#cicd-pipeline","title":"CI/CD Pipeline","text":""},{"location":"technical_overview/#github-actions","title":"GitHub Actions","text":"<ul> <li>What: Continuous Integration/Deployment platform</li> <li>Workflows:</li> <li>Quality Checks (<code>main.yml</code>):<ul> <li>Pre-commit validation</li> <li>Unit tests (Python 3.9-3.13)</li> <li>Type checking with mypy</li> <li>Coverage reporting to Codecov</li> <li>Documentation build verification</li> </ul> </li> <li>Release Process (<code>on-release-main.yml</code>):<ul> <li>Version updating</li> <li>PyPI package publishing</li> <li>Documentation deployment</li> </ul> </li> <li>Configuration Validation:<ul> <li>Codecov configuration validation</li> </ul> </li> <li>Learn More</li> </ul>"},{"location":"technical_overview/#codecov","title":"Codecov","text":"<ul> <li>What: Code coverage reporting service</li> <li>Usage: Track and visualize test coverage</li> <li>Features:</li> <li>PR comments</li> <li>Coverage trends</li> <li>Configuration validation</li> <li>Learn More</li> </ul>"},{"location":"technical_overview/#documentation","title":"Documentation","text":""},{"location":"technical_overview/#mkdocs","title":"MkDocs","text":"<ul> <li>What: Static site generator for documentation</li> <li>Version: \u22651.4.2</li> <li>Theme: Material for MkDocs (\u22658.5.10)</li> <li>Features:</li> <li>Navigation sections</li> <li>Search suggestions</li> <li>Content tabs</li> <li>Dark/light mode</li> <li>Learn More</li> </ul>"},{"location":"technical_overview/#mkdocstrings","title":"mkdocstrings","text":"<ul> <li>What: Automatic documentation from docstrings</li> <li>Version: \u22650.26.1</li> <li>Features:</li> <li>Python handler</li> <li>Source code display</li> <li>Category headings</li> <li>Submodule documentation</li> <li>Learn More</li> </ul>"},{"location":"technical_overview/#design-patterns","title":"Design Patterns","text":""},{"location":"technical_overview/#event-driven-architecture","title":"Event-Driven Architecture","text":"<ul> <li>What: Pattern where components communicate via events</li> <li>Implementation: WebSocket events and handlers</li> <li>Benefits:</li> <li>Loose coupling</li> <li>Scalability</li> <li>Real-time communication</li> </ul>"},{"location":"technical_overview/#decorator-pattern","title":"Decorator Pattern","text":"<ul> <li>What: Dynamically add behavior to objects</li> <li>Usage: <code>@websocket_handler</code> for event registration</li> <li>Benefits:</li> <li>Clean handler registration</li> <li>Separation of concerns</li> <li>Runtime flexibility</li> </ul>"},{"location":"technical_overview/#registry-pattern","title":"Registry Pattern","text":"<ul> <li>What: Central registry for components</li> <li>Usage: Handler registration system</li> <li>Benefits:</li> <li>Dynamic handler discovery</li> <li>Centralized management</li> <li>Runtime registration</li> </ul>"},{"location":"technical_overview/#factory-pattern","title":"Factory Pattern","text":"<ul> <li>What: Object creation abstraction</li> <li>Usage: Message creation utilities</li> <li>Benefits:</li> <li>Consistent message creation</li> <li>Encapsulation</li> <li>Flexible object creation</li> </ul>"},{"location":"technical_overview/#python-support","title":"Python Support","text":"<ul> <li>Required Version: \u22653.9, &lt;4.0</li> <li>Tested Versions:</li> <li>Python 3.9</li> <li>Python 3.10</li> <li>Python 3.11</li> <li>Python 3.12</li> <li>Python 3.13</li> </ul>"},{"location":"technical_overview/#dependencies","title":"Dependencies","text":""},{"location":"technical_overview/#runtime-dependencies","title":"Runtime Dependencies","text":"<ul> <li>fastapi \u22650.115.4</li> <li>prompt-toolkit \u22653.0.48</li> <li>rich \u226513.9.4</li> <li>typer \u22650.13.0</li> <li>uvicorn \u22650.32.0</li> <li>websockets \u226513.1</li> <li>pydantic \u22652.0.0</li> <li>structlog \u226523.1.0</li> </ul>"},{"location":"technical_overview/#development-dependencies","title":"Development Dependencies","text":"<p>All development dependencies are managed through uv and specified in pyproject.toml.</p>"},{"location":"ref/cli/","title":"CLI Reference","text":"<p>options: show_root_heading: true show_source: true members: - start_server - start_client - common_options</p>"},{"location":"ref/cli/#datadivr.cli","title":"<code>datadivr.cli</code>","text":"<p>Command-line interface for DataDivr.</p>"},{"location":"ref/cli/#datadivr.cli-functions","title":"Functions","text":""},{"location":"ref/cli/#datadivr.cli.start_client","title":"<code>start_client(port=8765, host='127.0.0.1', log_level='INFO')</code>","text":"<p>Start an interactive WebSocket client.</p> Source code in <code>datadivr/cli.py</code> <pre><code>@app_cli.command()\ndef start_client(port: int = 8765, host: str = \"127.0.0.1\", log_level: str = \"INFO\") -&gt; None:\n    \"\"\"Start an interactive WebSocket client.\"\"\"\n    start_client_app(host, port, log_level)\n</code></pre>"},{"location":"ref/cli/#datadivr.cli.start_server","title":"<code>start_server(port=8765, host='127.0.0.1', static_dir='./static', log_level='INFO', pretty=True)</code>","text":"<p>Start the WebSocket and static file server.</p> Source code in <code>datadivr/cli.py</code> <pre><code>@app_cli.command()\ndef start_server(\n    port: int = 8765,\n    host: str = \"127.0.0.1\",\n    static_dir: str | None = \"./static\",\n    log_level: str = \"INFO\",\n    pretty: bool = True,\n) -&gt; None:\n    \"\"\"Start the WebSocket and static file server.\"\"\"\n    start_server_app(host, port, static_dir, log_level, pretty)\n</code></pre>"},{"location":"ref/client/","title":"WebSocket Client","text":"<p>The datadivr client provides a simple interface for connecting to a WebSocket server and handling real-time communication.</p>"},{"location":"ref/client/#basic-usage","title":"Basic Usage","text":"<pre><code>import asyncio\nfrom datadivr import WebSocketClient, HandlerType, websocket_handler, WebSocketMessage\nfrom typing import Optional\n\n# Define handlers\n@websocket_handler(\"sum_handler_result\", HandlerType.CLIENT)\nasync def handle_sum_result(message: WebSocketMessage) -&gt; None:\n    \"\"\"Handle the result of a sum calculation.\"\"\"\n    print(f\"Sum result from {message.from_id}: {message.payload}\")\n\n@websocket_handler(\"msg\", HandlerType.CLIENT)\nasync def msg_handler(message: WebSocketMessage) -&gt; None:\n    \"\"\"Handle text messages.\"\"\"\n    print(f\"&gt;&gt; {message.from_id}: '{message.message}'\")\n\n# Create and run client\nasync def run_client() -&gt; None:\n    # Create and connect client\n    client = WebSocketClient(\"ws://localhost:8765/ws\")\n    await client.connect()\n\n    # Send a calculation request\n    await client.send_message(\n        payload={\"numbers\": [391, 29]},\n        event_name=\"sum_event\"\n    )\n\n    # Create tasks for message handling\n    tasks = [\n        asyncio.create_task(client.receive_messages()),\n    ]\n\n    try:\n        await asyncio.gather(*tasks)\n    finally:\n        for task in tasks:\n            task.cancel()\n        await client.disconnect()\n\n# Run the client\nasyncio.run(run_client())\n</code></pre>"},{"location":"ref/client/#built-in-handlers","title":"Built-in Handlers","text":"<p>The client comes with several built-in handlers:</p>"},{"location":"ref/client/#sum-handler","title":"Sum Handler","text":"<pre><code>@websocket_handler(\"sum_event_client\", HandlerType.CLIENT)\nasync def sum_handler(message: WebSocketMessage) -&gt; None:\n    \"\"\"Handle sum calculation results.\"\"\"\n    print(f\"Sum result from {message.from_id}: {message.payload}\")\n</code></pre>"},{"location":"ref/client/#message-handler","title":"Message Handler","text":"<pre><code>@websocket_handler(\"msg\", HandlerType.CLIENT)\nasync def msg_handler(message: WebSocketMessage) -&gt; None:\n    \"\"\"Handle text messages.\"\"\"\n    print(f\"&gt;&gt; {message.from_id}({message.event_name}): '{message.message}'\")\n</code></pre>"},{"location":"ref/client/#interactive-usage","title":"Interactive Usage","text":"<p>Here's how the CLI client uses these handlers:</p> <pre><code>async def run_client() -&gt; None:\n    # Create and connect client\n    client = WebSocketClient(f\"ws://{host}:{port}/ws\")\n    await client.connect()\n\n    # Create tasks for message handling and user input\n    tasks = [\n        asyncio.create_task(client.receive_messages()),\n        asyncio.create_task(input_loop(client)),\n    ]\n\n    try:\n        await asyncio.gather(*tasks)\n    finally:\n        for task in tasks:\n            task.cancel()\n        await client.disconnect()\n\n# Example JSON messages to send:\n# Sum calculation:\n{\"event_name\": \"sum_event\", \"payload\": {\"numbers\": [391, 29]}}\n# Broadcast message:\n{\"event_name\": \"msg\", \"to\": \"all\", \"message\": \"hello\"}\n</code></pre>"},{"location":"ref/client/#message-types","title":"Message Types","text":"<ol> <li>Sum Calculation:</li> </ol> <pre><code>await client.send_message(\n    payload={\"numbers\": [1, 2, 3]},\n    event_name=\"sum_event\"\n)\n</code></pre> <ol> <li>Text Messages:</li> </ol> <pre><code>await client.send_message(\n    message=\"Hello everyone!\",\n    event_name=\"msg\",\n    to=\"all\"\n)\n</code></pre> <ol> <li>Custom Events:</li> </ol> <pre><code>await client.send_message(\n    payload={\"data\": \"custom_data\"},\n    event_name=\"custom_event\",\n    to=\"specific_client_id\"\n)\n</code></pre>"},{"location":"ref/client/#error-handling","title":"Error Handling","text":"<p>The client handles several error conditions:</p> <ul> <li><code>NotConnectedError</code>: Raised when trying to send messages before connecting</li> <li><code>ConnectionClosed</code>: Handled during message reception</li> <li>Invalid message formats: Logged and handled gracefully</li> </ul>"},{"location":"ref/client/#connection-lifecycle","title":"Connection Lifecycle","text":"<ol> <li>Connection:</li> </ol> <pre><code>client = WebSocketClient(\"ws://localhost:8765/ws\")\nawait client.connect()  # Automatically registers handlers\n</code></pre> <ol> <li>Message Loop:</li> </ol> <pre><code># Start receiving messages (blocks until connection closes)\nawait client.receive_messages()\n</code></pre> <ol> <li>Disconnection:</li> </ol> <pre><code>await client.disconnect()  # Clean up connection\n</code></pre>"},{"location":"ref/client/#reference","title":"Reference","text":"<p>options: show_root_heading: true show_source: true</p>"},{"location":"ref/client/#datadivr.transport.client.WebSocketClient","title":"<code>datadivr.transport.client.WebSocketClient</code>","text":"<p>A WebSocket client for communicating with a datadivr server.</p> <p>This class handles the connection to a WebSocket server, message sending, and event handling for received messages.</p> <p>Attributes:</p> Name Type Description <code>uri</code> <p>The WebSocket server URI to connect to</p> <code>handlers</code> <p>Dictionary of registered event handlers</p> <code>websocket</code> <code>WebSocketClientProtocol | None</code> <p>The active WebSocket connection (if connected)</p> Example <pre><code>client = WebSocketClient(\"ws://localhost:8765/ws\")\nawait client.connect()\nawait client.send_message(payload=data, event_name=\"custom_event\")\n</code></pre> Source code in <code>datadivr/transport/client.py</code> <pre><code>class WebSocketClient:\n    \"\"\"A WebSocket client for communicating with a datadivr server.\n\n    This class handles the connection to a WebSocket server, message sending,\n    and event handling for received messages.\n\n    Attributes:\n        uri: The WebSocket server URI to connect to\n        handlers: Dictionary of registered event handlers\n        websocket: The active WebSocket connection (if connected)\n\n    Example:\n        ```python\n        client = WebSocketClient(\"ws://localhost:8765/ws\")\n        await client.connect()\n        await client.send_message(payload=data, event_name=\"custom_event\")\n        ```\n    \"\"\"\n\n    def __init__(self, uri: str):\n        \"\"\"Initialize the WebSocket client.\n\n        Args:\n            uri: The WebSocket server URI to connect to\n        \"\"\"\n        self.uri = uri\n        self.handlers = get_handlers(HandlerType.CLIENT)\n        self.websocket: WebSocketClientProtocol | None = None\n        self.logger = get_logger(__name__)\n\n    async def connect(self) -&gt; None:\n        \"\"\"Connect to the WebSocket server and send initial handler information.\"\"\"\n        try:\n            self.websocket = await websockets.connect(self.uri)\n            # await self.send_handler_names()\n        except ConnectionRefusedError as e:\n            self.logger.exception(\"connection_refused\", error=str(e))\n            raise\n        except Exception as e:\n            self.logger.exception(\"unexpected_error_during_connection\", error=str(e))\n            raise\n\n    async def receive_messages(self) -&gt; None:\n        \"\"\"Listen for incoming messages from the server.\"\"\"\n        if not self.websocket:\n            raise NotConnectedError()\n\n        try:\n            async for message in self.websocket:\n                self.logger.info(\"raw_message_received\", raw_message=message)\n                event_data = json.loads(message)\n                self.logger.info(\"message_received\", event_data=event_data)\n                await self.handle_event(event_data, self.websocket)\n        except websockets.exceptions.ConnectionClosed:\n            self.logger.info(\"connection_closed\")\n        finally:\n            await self.disconnect()\n\n    async def handle_event(self, event_data: dict, websocket: WebSocketClientProtocol) -&gt; None:\n        \"\"\"Handle an incoming event using registered handlers.\n\n        Args:\n            event_data: The received event data\n            websocket: The WebSocket connection to use for responses\n        \"\"\"\n        event_name = event_data[\"event_name\"]\n        if event_name in self.handlers:\n            self.logger.info(\"handling_event\", event_name=event_name)\n            handler = self.handlers[event_name]\n            message = WebSocketMessage.model_validate(event_data)\n            response = await handler(message)\n            if response and isinstance(response, WebSocketMessage):\n                await send_message(websocket, response)\n        else:\n            self.logger.debug(\n                \"no_handler_for_event\", event_name=event_name, event_data=json.dumps(event_data, indent=2)\n            )\n\n    async def send_message(self, payload: Any, event_name: str, msg: str | None = None, to: str = \"others\") -&gt; None:\n        \"\"\"Send a message to the server.\n\n        Args:\n            payload: The message payload\n            event_name: The name of the event\n            msg: Optional text message\n            to: The recipient of the message (default: \"others\")\n\n        Raises:\n            NotConnectedError: If called before connecting to the server\n        \"\"\"\n        if self.websocket:\n            message = WebSocketMessage(event_name=event_name, payload=payload, to=to, message=msg)\n            await send_message(self.websocket, message)\n        else:\n            raise NotConnectedError()\n\n    async def disconnect(self) -&gt; None:\n        \"\"\"Close the WebSocket connection.\"\"\"\n        if self.websocket:\n            try:\n                await self.websocket.close()\n            except Exception:\n                self.logger.exception(\"error_closing_connection\")\n            finally:\n                self.websocket = None\n\n    async def send_handler_names(self) -&gt; None:\n        \"\"\"Send a message with the names of all registered handlers.\n\n        This is called automatically after connection to inform the server\n        about available client-side handlers.\n        \"\"\"\n        handler_names = list(self.handlers.keys())\n        payload = {\"handlers\": handler_names}\n        self.logger.info(\"sending_handler_names\", handlers=handler_names)\n        await self.send_message(payload=payload, event_name=\"CLI_HELLO\", to=\"others\")\n</code></pre>"},{"location":"ref/client/#datadivr.transport.client.WebSocketClient-functions","title":"Functions","text":""},{"location":"ref/client/#datadivr.transport.client.WebSocketClient.__init__","title":"<code>__init__(uri)</code>","text":"<p>Initialize the WebSocket client.</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>The WebSocket server URI to connect to</p> required Source code in <code>datadivr/transport/client.py</code> <pre><code>def __init__(self, uri: str):\n    \"\"\"Initialize the WebSocket client.\n\n    Args:\n        uri: The WebSocket server URI to connect to\n    \"\"\"\n    self.uri = uri\n    self.handlers = get_handlers(HandlerType.CLIENT)\n    self.websocket: WebSocketClientProtocol | None = None\n    self.logger = get_logger(__name__)\n</code></pre>"},{"location":"ref/client/#datadivr.transport.client.WebSocketClient.connect","title":"<code>connect()</code>  <code>async</code>","text":"<p>Connect to the WebSocket server and send initial handler information.</p> Source code in <code>datadivr/transport/client.py</code> <pre><code>async def connect(self) -&gt; None:\n    \"\"\"Connect to the WebSocket server and send initial handler information.\"\"\"\n    try:\n        self.websocket = await websockets.connect(self.uri)\n        # await self.send_handler_names()\n    except ConnectionRefusedError as e:\n        self.logger.exception(\"connection_refused\", error=str(e))\n        raise\n    except Exception as e:\n        self.logger.exception(\"unexpected_error_during_connection\", error=str(e))\n        raise\n</code></pre>"},{"location":"ref/client/#datadivr.transport.client.WebSocketClient.disconnect","title":"<code>disconnect()</code>  <code>async</code>","text":"<p>Close the WebSocket connection.</p> Source code in <code>datadivr/transport/client.py</code> <pre><code>async def disconnect(self) -&gt; None:\n    \"\"\"Close the WebSocket connection.\"\"\"\n    if self.websocket:\n        try:\n            await self.websocket.close()\n        except Exception:\n            self.logger.exception(\"error_closing_connection\")\n        finally:\n            self.websocket = None\n</code></pre>"},{"location":"ref/client/#datadivr.transport.client.WebSocketClient.handle_event","title":"<code>handle_event(event_data, websocket)</code>  <code>async</code>","text":"<p>Handle an incoming event using registered handlers.</p> <p>Parameters:</p> Name Type Description Default <code>event_data</code> <code>dict</code> <p>The received event data</p> required <code>websocket</code> <code>WebSocketClientProtocol</code> <p>The WebSocket connection to use for responses</p> required Source code in <code>datadivr/transport/client.py</code> <pre><code>async def handle_event(self, event_data: dict, websocket: WebSocketClientProtocol) -&gt; None:\n    \"\"\"Handle an incoming event using registered handlers.\n\n    Args:\n        event_data: The received event data\n        websocket: The WebSocket connection to use for responses\n    \"\"\"\n    event_name = event_data[\"event_name\"]\n    if event_name in self.handlers:\n        self.logger.info(\"handling_event\", event_name=event_name)\n        handler = self.handlers[event_name]\n        message = WebSocketMessage.model_validate(event_data)\n        response = await handler(message)\n        if response and isinstance(response, WebSocketMessage):\n            await send_message(websocket, response)\n    else:\n        self.logger.debug(\n            \"no_handler_for_event\", event_name=event_name, event_data=json.dumps(event_data, indent=2)\n        )\n</code></pre>"},{"location":"ref/client/#datadivr.transport.client.WebSocketClient.receive_messages","title":"<code>receive_messages()</code>  <code>async</code>","text":"<p>Listen for incoming messages from the server.</p> Source code in <code>datadivr/transport/client.py</code> <pre><code>async def receive_messages(self) -&gt; None:\n    \"\"\"Listen for incoming messages from the server.\"\"\"\n    if not self.websocket:\n        raise NotConnectedError()\n\n    try:\n        async for message in self.websocket:\n            self.logger.info(\"raw_message_received\", raw_message=message)\n            event_data = json.loads(message)\n            self.logger.info(\"message_received\", event_data=event_data)\n            await self.handle_event(event_data, self.websocket)\n    except websockets.exceptions.ConnectionClosed:\n        self.logger.info(\"connection_closed\")\n    finally:\n        await self.disconnect()\n</code></pre>"},{"location":"ref/client/#datadivr.transport.client.WebSocketClient.send_handler_names","title":"<code>send_handler_names()</code>  <code>async</code>","text":"<p>Send a message with the names of all registered handlers.</p> <p>This is called automatically after connection to inform the server about available client-side handlers.</p> Source code in <code>datadivr/transport/client.py</code> <pre><code>async def send_handler_names(self) -&gt; None:\n    \"\"\"Send a message with the names of all registered handlers.\n\n    This is called automatically after connection to inform the server\n    about available client-side handlers.\n    \"\"\"\n    handler_names = list(self.handlers.keys())\n    payload = {\"handlers\": handler_names}\n    self.logger.info(\"sending_handler_names\", handlers=handler_names)\n    await self.send_message(payload=payload, event_name=\"CLI_HELLO\", to=\"others\")\n</code></pre>"},{"location":"ref/client/#datadivr.transport.client.WebSocketClient.send_message","title":"<code>send_message(payload, event_name, msg=None, to='others')</code>  <code>async</code>","text":"<p>Send a message to the server.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>Any</code> <p>The message payload</p> required <code>event_name</code> <code>str</code> <p>The name of the event</p> required <code>msg</code> <code>str | None</code> <p>Optional text message</p> <code>None</code> <code>to</code> <code>str</code> <p>The recipient of the message (default: \"others\")</p> <code>'others'</code> <p>Raises:</p> Type Description <code>NotConnectedError</code> <p>If called before connecting to the server</p> Source code in <code>datadivr/transport/client.py</code> <pre><code>async def send_message(self, payload: Any, event_name: str, msg: str | None = None, to: str = \"others\") -&gt; None:\n    \"\"\"Send a message to the server.\n\n    Args:\n        payload: The message payload\n        event_name: The name of the event\n        msg: Optional text message\n        to: The recipient of the message (default: \"others\")\n\n    Raises:\n        NotConnectedError: If called before connecting to the server\n    \"\"\"\n    if self.websocket:\n        message = WebSocketMessage(event_name=event_name, payload=payload, to=to, message=msg)\n        await send_message(self.websocket, message)\n    else:\n        raise NotConnectedError()\n</code></pre>"},{"location":"ref/handlers/","title":"Handlers","text":""},{"location":"ref/handlers/#sum-handler","title":"Sum Handler","text":"<p>options: show_root_heading: true show_source: true</p>"},{"location":"ref/handlers/#datadivr.handlers","title":"<code>datadivr.handlers</code>","text":"<p>Message handlers for DataDivr.</p>"},{"location":"ref/handlers/#datadivr.handlers-classes","title":"Classes","text":""},{"location":"ref/handlers/#datadivr.handlers.HandlerType","title":"<code>HandlerType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Type of handler to register.</p> Source code in <code>datadivr/handlers/registry.py</code> <pre><code>class HandlerType(Enum):\n    \"\"\"Type of handler to register.\"\"\"\n\n    SERVER = auto()\n    CLIENT = auto()\n    BOTH = auto()\n</code></pre>"},{"location":"ref/handlers/#datadivr.handlers-functions","title":"Functions","text":""},{"location":"ref/handlers/#datadivr.handlers.get_handlers","title":"<code>get_handlers(handler_type=HandlerType.SERVER)</code>","text":"<p>Get registered handlers for the specified type.</p> <p>Parameters:</p> Name Type Description Default <code>handler_type</code> <code>HandlerType</code> <p>Type of handlers to retrieve (SERVER or CLIENT)</p> <code>SERVER</code> Source code in <code>datadivr/handlers/registry.py</code> <pre><code>def get_handlers(\n    handler_type: HandlerType = HandlerType.SERVER,\n) -&gt; dict[str, Callable[[WebSocketMessage], Awaitable[WebSocketMessage | None]]]:\n    \"\"\"\n    Get registered handlers for the specified type.\n\n    Args:\n        handler_type: Type of handlers to retrieve (SERVER or CLIENT)\n    \"\"\"\n    if handler_type == HandlerType.SERVER:\n        return _server_handlers\n    return _client_handlers\n</code></pre>"},{"location":"ref/handlers/#datadivr.handlers.get_node_info_handler","title":"<code>get_node_info_handler(message)</code>  <code>async</code>","text":"<p>Handle requests to get information about a specific node.</p> Source code in <code>datadivr/handlers/custom_handlers.py</code> <pre><code>@websocket_handler(\"get_node_info\", HandlerType.SERVER)\nasync def get_node_info_handler(message: WebSocketMessage) -&gt; WebSocketMessage:\n    \"\"\"Handle requests to get information about a specific node.\"\"\"\n    node_index = message.payload.get(\"index\") if message.payload else None\n    current_project = ProjectManager.get_current_project()\n\n    if current_project is None:\n        return WebSocketMessage(\n            event_name=\"get_node_info_result\", payload={\"error\": \"No project is currently open\"}, to=message.from_id\n        )\n\n    if node_index is None:\n        return WebSocketMessage(\n            event_name=\"get_node_info_result\", payload={\"error\": \"Node index not provided\"}, to=message.from_id\n        )\n\n    try:\n        node_data = (\n            current_project.nodes_data.get_attributes_by_index(node_index) if current_project.nodes_data else None\n        )\n\n        if node_data is None:\n            return WebSocketMessage(\n                event_name=\"get_node_info_result\", payload={\"error\": \"Node data not found\"}, to=message.from_id\n            )\n\n        # Convert all float32 values to float\n        node_data = {k: float(v) if isinstance(v, np.float32) else v for k, v in node_data.items()}\n\n        return WebSocketMessage(event_name=\"get_node_info_result\", payload=node_data, to=message.from_id)\n    except IndexError as e:\n        return WebSocketMessage(event_name=\"get_node_info_result\", payload={\"error\": str(e)}, to=message.from_id)\n    except Exception as e:\n        return WebSocketMessage(event_name=\"get_node_info_result\", payload={\"error\": str(e)}, to=message.from_id)\n</code></pre>"},{"location":"ref/handlers/#datadivr.handlers.handle_sum_result","title":"<code>handle_sum_result(message)</code>  <code>async</code>","text":"<p>Handle the result of a sum calculation on the client side.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>WebSocketMessage</code> <p>A WebSocketMessage containing the sum result in its payload</p> required Source code in <code>datadivr/handlers/builtin/sum_handler.py</code> <pre><code>@websocket_handler(\"sum_handler_result\", HandlerType.CLIENT)\nasync def handle_sum_result(message: WebSocketMessage) -&gt; None:\n    \"\"\"Handle the result of a sum calculation on the client side.\n\n    Args:\n        message: A WebSocketMessage containing the sum result in its payload\n    \"\"\"\n    print(f\"*** handle_sum_result(): {message.from_id}: '{message.payload}'\")\n    return None\n</code></pre>"},{"location":"ref/handlers/#datadivr.handlers.msg_handler","title":"<code>msg_handler(message)</code>  <code>async</code>","text":"<p>Handle generic text messages on the client side.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>WebSocketMessage</code> <p>A WebSocketMessage containing a text message</p> required Source code in <code>datadivr/handlers/builtin/sum_handler.py</code> <pre><code>@websocket_handler(\"msg\", HandlerType.CLIENT)\nasync def msg_handler(message: WebSocketMessage) -&gt; None:\n    \"\"\"Handle generic text messages on the client side.\n\n    Args:\n        message: A WebSocketMessage containing a text message\n    \"\"\"\n    print(f\"&gt;&gt; {message.from_id}({message.event_name}): '{message.message}'\")\n    return None\n</code></pre>"},{"location":"ref/handlers/#datadivr.handlers.sum_handler","title":"<code>sum_handler(message)</code>  <code>async</code>","text":"<p>Handle requests to calculate the sum of a list of numbers.</p> <p>This handler processes both server and client-side sum calculation requests. It expects a payload containing a list of numbers and returns their sum.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>WebSocketMessage</code> <p>A WebSocketMessage containing a payload with a \"numbers\" key     holding a list of numeric values</p> required <p>Returns:</p> Name Type Description <code>WebSocketMessage</code> <code>WebSocketMessage</code> <p>A message containing the sum result or an error message</p> Example payload <p>{\"numbers\": [1, 2, 3, 4, 5]}</p> Source code in <code>datadivr/handlers/builtin/sum_handler.py</code> <pre><code>@websocket_handler(\"sum_event\", HandlerType.SERVER)\n@websocket_handler(\"sum_event_client\", HandlerType.CLIENT)\nasync def sum_handler(message: WebSocketMessage) -&gt; WebSocketMessage:\n    \"\"\"Handle requests to calculate the sum of a list of numbers.\n\n    This handler processes both server and client-side sum calculation requests.\n    It expects a payload containing a list of numbers and returns their sum.\n\n    Args:\n        message: A WebSocketMessage containing a payload with a \"numbers\" key\n                holding a list of numeric values\n\n    Returns:\n        WebSocketMessage: A message containing the sum result or an error message\n\n    Example payload:\n        {\"numbers\": [1, 2, 3, 4, 5]}\n    \"\"\"\n    try:\n        payload = message.payload\n        if not isinstance(payload, dict):\n            return create_error_message(\"Invalid payload format\", message.from_id)\n\n        numbers = payload.get(\"numbers\")\n        if not isinstance(numbers, list):\n            return create_error_message(\"Payload must contain a list of numbers\", message.from_id)\n\n        result = sum(float(n) for n in numbers)\n        return WebSocketMessage(\n            event_name=\"sum_handler_result\",\n            payload=result,\n            to=message.from_id,\n        )\n    except Exception as e:\n        return create_error_message(f\"Error: {e!s}\", message.from_id)\n</code></pre>"},{"location":"ref/handlers/#datadivr.handlers.websocket_handler","title":"<code>websocket_handler(event_name, handler_type=HandlerType.SERVER)</code>","text":"<p>Decorator to register a websocket handler function.</p> <p>Parameters:</p> Name Type Description Default <code>event_name</code> <code>str</code> <p>The event name to register the handler for.</p> required <code>handler_type</code> <code>HandlerType</code> <p>Where this handler should be registered (SERVER, CLIENT, or BOTH)</p> <code>SERVER</code> Example <p>@websocket_handler(\"sum_event\", HandlerType.BOTH) async def sum_handler(message: WebSocketMessage) -&gt; Optional[WebSocketMessage]:     ...</p> Source code in <code>datadivr/handlers/registry.py</code> <pre><code>def websocket_handler(\n    event_name: str, handler_type: HandlerType = HandlerType.SERVER\n) -&gt; Callable[[Callable[..., Awaitable[WebSocketMessage | None]]], Callable[..., Awaitable[WebSocketMessage | None]]]:\n    \"\"\"\n    Decorator to register a websocket handler function.\n\n    Args:\n        event_name: The event name to register the handler for.\n        handler_type: Where this handler should be registered (SERVER, CLIENT, or BOTH)\n\n    Example:\n        @websocket_handler(\"sum_event\", HandlerType.BOTH)\n        async def sum_handler(message: WebSocketMessage) -&gt; Optional[WebSocketMessage]:\n            ...\n    \"\"\"\n\n    def decorator(\n        func: Callable[..., Awaitable[WebSocketMessage | None]],\n    ) -&gt; Callable[..., Awaitable[WebSocketMessage | None]]:\n        @wraps(func)\n        async def wrapper(*args: Any, **kwargs: Any) -&gt; WebSocketMessage | None:\n            return await func(*args, **kwargs)\n\n        if handler_type in (HandlerType.SERVER, HandlerType.BOTH):\n            _server_handlers[event_name] = wrapper\n        if handler_type in (HandlerType.CLIENT, HandlerType.BOTH):\n            _client_handlers[event_name] = wrapper\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"ref/handlers/#datadivr.handlers-modules","title":"Modules","text":""},{"location":"ref/handlers/#datadivr.handlers.builtin","title":"<code>builtin</code>","text":"<p>Built-in message handlers.</p>"},{"location":"ref/handlers/#datadivr.handlers.builtin-modules","title":"Modules","text":""},{"location":"ref/handlers/#datadivr.handlers.builtin.sum_handler","title":"<code>sum_handler</code>","text":"Classes Functions <code>handle_sum_result(message)</code> <code>async</code> <p>Handle the result of a sum calculation on the client side.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>WebSocketMessage</code> <p>A WebSocketMessage containing the sum result in its payload</p> required Source code in <code>datadivr/handlers/builtin/sum_handler.py</code> <pre><code>@websocket_handler(\"sum_handler_result\", HandlerType.CLIENT)\nasync def handle_sum_result(message: WebSocketMessage) -&gt; None:\n    \"\"\"Handle the result of a sum calculation on the client side.\n\n    Args:\n        message: A WebSocketMessage containing the sum result in its payload\n    \"\"\"\n    print(f\"*** handle_sum_result(): {message.from_id}: '{message.payload}'\")\n    return None\n</code></pre> <code>msg_handler(message)</code> <code>async</code> <p>Handle generic text messages on the client side.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>WebSocketMessage</code> <p>A WebSocketMessage containing a text message</p> required Source code in <code>datadivr/handlers/builtin/sum_handler.py</code> <pre><code>@websocket_handler(\"msg\", HandlerType.CLIENT)\nasync def msg_handler(message: WebSocketMessage) -&gt; None:\n    \"\"\"Handle generic text messages on the client side.\n\n    Args:\n        message: A WebSocketMessage containing a text message\n    \"\"\"\n    print(f\"&gt;&gt; {message.from_id}({message.event_name}): '{message.message}'\")\n    return None\n</code></pre> <code>sum_handler(message)</code> <code>async</code> <p>Handle requests to calculate the sum of a list of numbers.</p> <p>This handler processes both server and client-side sum calculation requests. It expects a payload containing a list of numbers and returns their sum.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>WebSocketMessage</code> <p>A WebSocketMessage containing a payload with a \"numbers\" key     holding a list of numeric values</p> required <p>Returns:</p> Name Type Description <code>WebSocketMessage</code> <code>WebSocketMessage</code> <p>A message containing the sum result or an error message</p> Example payload <p>{\"numbers\": [1, 2, 3, 4, 5]}</p> Source code in <code>datadivr/handlers/builtin/sum_handler.py</code> <pre><code>@websocket_handler(\"sum_event\", HandlerType.SERVER)\n@websocket_handler(\"sum_event_client\", HandlerType.CLIENT)\nasync def sum_handler(message: WebSocketMessage) -&gt; WebSocketMessage:\n    \"\"\"Handle requests to calculate the sum of a list of numbers.\n\n    This handler processes both server and client-side sum calculation requests.\n    It expects a payload containing a list of numbers and returns their sum.\n\n    Args:\n        message: A WebSocketMessage containing a payload with a \"numbers\" key\n                holding a list of numeric values\n\n    Returns:\n        WebSocketMessage: A message containing the sum result or an error message\n\n    Example payload:\n        {\"numbers\": [1, 2, 3, 4, 5]}\n    \"\"\"\n    try:\n        payload = message.payload\n        if not isinstance(payload, dict):\n            return create_error_message(\"Invalid payload format\", message.from_id)\n\n        numbers = payload.get(\"numbers\")\n        if not isinstance(numbers, list):\n            return create_error_message(\"Payload must contain a list of numbers\", message.from_id)\n\n        result = sum(float(n) for n in numbers)\n        return WebSocketMessage(\n            event_name=\"sum_handler_result\",\n            payload=result,\n            to=message.from_id,\n        )\n    except Exception as e:\n        return create_error_message(f\"Error: {e!s}\", message.from_id)\n</code></pre>"},{"location":"ref/handlers/#datadivr.handlers.custom_handlers","title":"<code>custom_handlers</code>","text":""},{"location":"ref/handlers/#datadivr.handlers.custom_handlers-classes","title":"Classes","text":""},{"location":"ref/handlers/#datadivr.handlers.custom_handlers-functions","title":"Functions","text":""},{"location":"ref/handlers/#datadivr.handlers.custom_handlers.get_node_info_handler","title":"<code>get_node_info_handler(message)</code>  <code>async</code>","text":"<p>Handle requests to get information about a specific node.</p> Source code in <code>datadivr/handlers/custom_handlers.py</code> <pre><code>@websocket_handler(\"get_node_info\", HandlerType.SERVER)\nasync def get_node_info_handler(message: WebSocketMessage) -&gt; WebSocketMessage:\n    \"\"\"Handle requests to get information about a specific node.\"\"\"\n    node_index = message.payload.get(\"index\") if message.payload else None\n    current_project = ProjectManager.get_current_project()\n\n    if current_project is None:\n        return WebSocketMessage(\n            event_name=\"get_node_info_result\", payload={\"error\": \"No project is currently open\"}, to=message.from_id\n        )\n\n    if node_index is None:\n        return WebSocketMessage(\n            event_name=\"get_node_info_result\", payload={\"error\": \"Node index not provided\"}, to=message.from_id\n        )\n\n    try:\n        node_data = (\n            current_project.nodes_data.get_attributes_by_index(node_index) if current_project.nodes_data else None\n        )\n\n        if node_data is None:\n            return WebSocketMessage(\n                event_name=\"get_node_info_result\", payload={\"error\": \"Node data not found\"}, to=message.from_id\n            )\n\n        # Convert all float32 values to float\n        node_data = {k: float(v) if isinstance(v, np.float32) else v for k, v in node_data.items()}\n\n        return WebSocketMessage(event_name=\"get_node_info_result\", payload=node_data, to=message.from_id)\n    except IndexError as e:\n        return WebSocketMessage(event_name=\"get_node_info_result\", payload={\"error\": str(e)}, to=message.from_id)\n    except Exception as e:\n        return WebSocketMessage(event_name=\"get_node_info_result\", payload={\"error\": str(e)}, to=message.from_id)\n</code></pre>"},{"location":"ref/handlers/#datadivr.handlers.custom_handlers.handle_client_overview","title":"<code>handle_client_overview(message)</code>  <code>async</code>","text":"<p>Handle client overview messages.</p> Source code in <code>datadivr/handlers/custom_handlers.py</code> <pre><code>@websocket_handler(\"client_overview\", HandlerType.CLIENT)\nasync def handle_client_overview(message: WebSocketMessage) -&gt; None:\n    \"\"\"Handle client overview messages.\"\"\"\n    if not message.payload:\n        return\n\n    overview = message.payload\n    logger.info(\n        \"Client Overview Update: \",\n        clients=len(overview[\"client_ids\"]),\n        ids=overview[\"client_ids\"],\n        time=overview[\"timestamp\"],\n    )\n</code></pre>"},{"location":"ref/handlers/#datadivr.handlers.registry","title":"<code>registry</code>","text":""},{"location":"ref/handlers/#datadivr.handlers.registry-classes","title":"Classes","text":""},{"location":"ref/handlers/#datadivr.handlers.registry.HandlerType","title":"<code>HandlerType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Type of handler to register.</p> Source code in <code>datadivr/handlers/registry.py</code> <pre><code>class HandlerType(Enum):\n    \"\"\"Type of handler to register.\"\"\"\n\n    SERVER = auto()\n    CLIENT = auto()\n    BOTH = auto()\n</code></pre>"},{"location":"ref/handlers/#datadivr.handlers.registry-functions","title":"Functions","text":""},{"location":"ref/handlers/#datadivr.handlers.registry.get_handlers","title":"<code>get_handlers(handler_type=HandlerType.SERVER)</code>","text":"<p>Get registered handlers for the specified type.</p> <p>Parameters:</p> Name Type Description Default <code>handler_type</code> <code>HandlerType</code> <p>Type of handlers to retrieve (SERVER or CLIENT)</p> <code>SERVER</code> Source code in <code>datadivr/handlers/registry.py</code> <pre><code>def get_handlers(\n    handler_type: HandlerType = HandlerType.SERVER,\n) -&gt; dict[str, Callable[[WebSocketMessage], Awaitable[WebSocketMessage | None]]]:\n    \"\"\"\n    Get registered handlers for the specified type.\n\n    Args:\n        handler_type: Type of handlers to retrieve (SERVER or CLIENT)\n    \"\"\"\n    if handler_type == HandlerType.SERVER:\n        return _server_handlers\n    return _client_handlers\n</code></pre>"},{"location":"ref/handlers/#datadivr.handlers.registry.websocket_handler","title":"<code>websocket_handler(event_name, handler_type=HandlerType.SERVER)</code>","text":"<p>Decorator to register a websocket handler function.</p> <p>Parameters:</p> Name Type Description Default <code>event_name</code> <code>str</code> <p>The event name to register the handler for.</p> required <code>handler_type</code> <code>HandlerType</code> <p>Where this handler should be registered (SERVER, CLIENT, or BOTH)</p> <code>SERVER</code> Example <p>@websocket_handler(\"sum_event\", HandlerType.BOTH) async def sum_handler(message: WebSocketMessage) -&gt; Optional[WebSocketMessage]:     ...</p> Source code in <code>datadivr/handlers/registry.py</code> <pre><code>def websocket_handler(\n    event_name: str, handler_type: HandlerType = HandlerType.SERVER\n) -&gt; Callable[[Callable[..., Awaitable[WebSocketMessage | None]]], Callable[..., Awaitable[WebSocketMessage | None]]]:\n    \"\"\"\n    Decorator to register a websocket handler function.\n\n    Args:\n        event_name: The event name to register the handler for.\n        handler_type: Where this handler should be registered (SERVER, CLIENT, or BOTH)\n\n    Example:\n        @websocket_handler(\"sum_event\", HandlerType.BOTH)\n        async def sum_handler(message: WebSocketMessage) -&gt; Optional[WebSocketMessage]:\n            ...\n    \"\"\"\n\n    def decorator(\n        func: Callable[..., Awaitable[WebSocketMessage | None]],\n    ) -&gt; Callable[..., Awaitable[WebSocketMessage | None]]:\n        @wraps(func)\n        async def wrapper(*args: Any, **kwargs: Any) -&gt; WebSocketMessage | None:\n            return await func(*args, **kwargs)\n\n        if handler_type in (HandlerType.SERVER, HandlerType.BOTH):\n            _server_handlers[event_name] = wrapper\n        if handler_type in (HandlerType.CLIENT, HandlerType.BOTH):\n            _client_handlers[event_name] = wrapper\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"ref/model_project/","title":"Project Functionality","text":""},{"location":"ref/model_project/#overview","title":"Overview","text":"<p>Functionality for managing a DataDiVR project, including reading and writing project files in both JSON and binary formats.</p>"},{"location":"ref/model_project/#data-structure","title":"Data Structure","text":""},{"location":"ref/model_project/#core-components","title":"Core Components","text":""},{"location":"ref/model_project/#project","title":"Project","text":"<p>The root model representing a DataDiVR project. Contains all data necessary to represent and visualize a network of nodes, their connections, and various layouts.</p> <p>Key Attributes:</p> <ul> <li><code>name</code>: Project display name</li> <li><code>attributes</code>: Optional key-value pairs for project metadata</li> <li><code>nodes_data</code>: Efficient storage for node information (IDs, names, attributes)</li> <li><code>links_data</code>: Storage for node connections</li> <li><code>layouts_data</code>: Dictionary of layout configurations</li> <li><code>selections</code>: Optional list of node selection groups</li> </ul>"},{"location":"ref/model_project/#data-storage-classes","title":"Data Storage Classes","text":""},{"location":"ref/model_project/#nodedata","title":"NodeData","text":"<p>Efficient storage for large node datasets:</p> <ul> <li><code>ids</code>: Array of node IDs (numpy int32)</li> <li><code>names</code>: Parallel array of names</li> <li><code>attributes</code>: Sparse dictionary of attributes keyed by node ID</li> </ul>"},{"location":"ref/model_project/#layoutdata","title":"LayoutData","text":"<p>Storage for layout positions:</p> <ul> <li><code>node_ids</code>: Array of node IDs (numpy int32)</li> <li><code>positions</code>: Array of 3D positions (numpy float32)</li> <li><code>colors</code>: Array of RGBA colors (numpy uint8)</li> </ul>"},{"location":"ref/model_project/#linkdata","title":"LinkData","text":"<p>Storage for node connections:</p> <ul> <li><code>start_ids</code>: Array of source IDs (numpy int32)</li> <li><code>end_ids</code>: Array of target IDs (numpy int32)</li> <li><code>colors</code>: Array of RGBA colors (numpy uint8)</li> </ul>"},{"location":"ref/model_project/#file-formats","title":"File Formats","text":"<p>The project supports two file formats:</p>"},{"location":"ref/model_project/#json-format","title":"JSON Format","text":"<ul> <li>Human-readable format</li> <li>Uses optimized orjson serialization</li> <li>Suitable for very small projects</li> </ul>"},{"location":"ref/model_project/#binary-format","title":"Binary Format","text":"<ul> <li>Compressed zip file containing:</li> <li><code>metadata.json</code>: Project metadata and non-array data</li> <li><code>arrays/*.npy</code>: Binary numpy arrays for large datasets</li> <li>Optimized for large projects with significant numerical data</li> <li>Uses numpy's native format for efficient storage of arrays</li> <li>much smaller file size than JSON</li> <li>faster to load (10x+)</li> </ul>"},{"location":"ref/model_project/#color-representation","title":"Color Representation","text":"<p>Colors are represented using RGBA format:</p> <ul> <li>Type: <code>RGBAColor = tuple[int, int, int, int]</code></li> <li>Values: Four integers representing Red, Green, Blue, and Alpha channels</li> </ul> <p>options: show_root_heading: true heading_level: 2 members: [Project, Node, Link, Layout, LayoutNodePosition, Selection] show_source: false</p>"},{"location":"ref/model_project/#datadivr.project.model","title":"<code>datadivr.project.model</code>","text":""},{"location":"ref/model_project/#datadivr.project.model-attributes","title":"Attributes","text":""},{"location":"ref/model_project/#datadivr.project.model.RGBAColor","title":"<code>RGBAColor = tuple[int, int, int, int]</code>  <code>module-attribute</code>","text":"<p>Type alias for RGBA colors represented as a tuple of 4 integers (r,g,b,a).</p>"},{"location":"ref/model_project/#datadivr.project.model-classes","title":"Classes","text":""},{"location":"ref/model_project/#datadivr.project.model.LayoutData","title":"<code>LayoutData</code>  <code>dataclass</code>","text":"<p>Efficient storage for layout positions</p> Source code in <code>datadivr/project/model.py</code> <pre><code>@dataclass\nclass LayoutData:\n    \"\"\"Efficient storage for layout positions\"\"\"\n\n    node_ids: npt.NDArray[np.int32]  # Array of node IDs (N,)\n    positions: npt.NDArray[np.float32]  # Array of positions (N, 3)\n    colors: npt.NDArray[np.uint8]  # Array of RGBA colors (N, 4)\n</code></pre>"},{"location":"ref/model_project/#datadivr.project.model.LayoutNotFoundError","title":"<code>LayoutNotFoundError</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when a requested layout is not found in the project.</p> Source code in <code>datadivr/project/model.py</code> <pre><code>class LayoutNotFoundError(ValueError):\n    \"\"\"Raised when a requested layout is not found in the project.\"\"\"\n\n    pass\n</code></pre>"},{"location":"ref/model_project/#datadivr.project.model.LinkData","title":"<code>LinkData</code>  <code>dataclass</code>","text":"<p>Efficient storage for links</p> Source code in <code>datadivr/project/model.py</code> <pre><code>@dataclass\nclass LinkData:\n    \"\"\"Efficient storage for links\"\"\"\n\n    start_ids: npt.NDArray[np.int32]  # Array of source IDs (M,)\n    end_ids: npt.NDArray[np.int32]  # Array of target IDs (M,)\n    colors: npt.NDArray[np.uint8]  # Array of RGBA colors (M, 4)\n</code></pre>"},{"location":"ref/model_project/#datadivr.project.model.NodeData","title":"<code>NodeData</code>  <code>dataclass</code>","text":"<p>Efficient storage for large node datasets using parallel numpy arrays</p> Source code in <code>datadivr/project/model.py</code> <pre><code>@dataclass\nclass NodeData:\n    \"\"\"Efficient storage for large node datasets using parallel numpy arrays\"\"\"\n\n    ids: npt.NDArray[np.int32]  # Array of node IDs (N,)\n\n    # Store attributes in separate arrays by data type for efficiency\n    str_attributes: dict[str, npt.NDArray[np.dtype(\"O\")]]  # type: ignore[valid-type]  # String attributes (N,)\n    float_attributes: dict[str, npt.NDArray[np.float32]]  # Float attributes (N,)\n    int_attributes: dict[str, npt.NDArray[np.int32]]  # Integer attributes (N,)\n    bool_attributes: dict[str, npt.NDArray[np.bool_]]  # Boolean attributes (N,)\n\n    def __init__(self, ids: npt.NDArray[np.int32]):\n        self.ids = ids\n        self.str_attributes = {}\n        self.float_attributes = {}\n        self.int_attributes = {}\n        self.bool_attributes = {}\n\n    def add_attribute(self, name: str, values: npt.NDArray, dtype: Any) -&gt; None:\n        \"\"\"Add a new attribute array of specified type\"\"\"\n        if np.issubdtype(dtype, np.floating):\n            self.float_attributes[name] = values.astype(np.float32)\n        elif np.issubdtype(dtype, np.integer):\n            self.int_attributes[name] = values.astype(np.int32)\n        elif np.issubdtype(dtype, np.bool_):\n            self.bool_attributes[name] = values.astype(np.bool_)\n        else:\n            self.str_attributes[name] = values.astype(\"O\")\n\n    def get_attribute(self, name: str) -&gt; npt.NDArray:\n        \"\"\"Get attribute array by name\"\"\"\n        if name not in self.attribute_names:\n            logger.error(\n                \"Requested attribute not found\", requested_attribute=name, available_attributes=self.attribute_names\n            )\n            raise AttributeNotFoundError(name)\n\n        for attr_dict in [self.str_attributes, self.float_attributes, self.int_attributes, self.bool_attributes]:\n            if name in attr_dict:\n                return attr_dict[name]\n        # This point should not be reached due to the check above\n        raise AttributeNotFoundError(name)\n\n    @property\n    def attribute_names(self) -&gt; set[str]:\n        \"\"\"Get all available attribute names\"\"\"\n        names: set[str] = set()\n        for attr_dict in [self.str_attributes, self.float_attributes, self.int_attributes, self.bool_attributes]:\n            names.update(attr_dict.keys())\n        return names\n\n    def get_attributes_by_index(self, index: int) -&gt; dict[str, Any]:\n        \"\"\"Get all attributes for a node by its index.\"\"\"\n        if index &lt; 0 or index &gt;= len(self.ids):\n            raise NodeIndexOutOfBoundsError(index, len(self.ids))\n\n        attributes = {}\n        for attr_dict in [self.str_attributes, self.float_attributes, self.int_attributes, self.bool_attributes]:\n            for name, values in attr_dict.items():\n                attributes[name] = values[index]\n        return attributes\n</code></pre>"},{"location":"ref/model_project/#datadivr.project.model.NodeData-attributes","title":"Attributes","text":""},{"location":"ref/model_project/#datadivr.project.model.NodeData.attribute_names","title":"<code>attribute_names: set[str]</code>  <code>property</code>","text":"<p>Get all available attribute names</p>"},{"location":"ref/model_project/#datadivr.project.model.NodeData-functions","title":"Functions","text":""},{"location":"ref/model_project/#datadivr.project.model.NodeData.add_attribute","title":"<code>add_attribute(name, values, dtype)</code>","text":"<p>Add a new attribute array of specified type</p> Source code in <code>datadivr/project/model.py</code> <pre><code>def add_attribute(self, name: str, values: npt.NDArray, dtype: Any) -&gt; None:\n    \"\"\"Add a new attribute array of specified type\"\"\"\n    if np.issubdtype(dtype, np.floating):\n        self.float_attributes[name] = values.astype(np.float32)\n    elif np.issubdtype(dtype, np.integer):\n        self.int_attributes[name] = values.astype(np.int32)\n    elif np.issubdtype(dtype, np.bool_):\n        self.bool_attributes[name] = values.astype(np.bool_)\n    else:\n        self.str_attributes[name] = values.astype(\"O\")\n</code></pre>"},{"location":"ref/model_project/#datadivr.project.model.NodeData.get_attribute","title":"<code>get_attribute(name)</code>","text":"<p>Get attribute array by name</p> Source code in <code>datadivr/project/model.py</code> <pre><code>def get_attribute(self, name: str) -&gt; npt.NDArray:\n    \"\"\"Get attribute array by name\"\"\"\n    if name not in self.attribute_names:\n        logger.error(\n            \"Requested attribute not found\", requested_attribute=name, available_attributes=self.attribute_names\n        )\n        raise AttributeNotFoundError(name)\n\n    for attr_dict in [self.str_attributes, self.float_attributes, self.int_attributes, self.bool_attributes]:\n        if name in attr_dict:\n            return attr_dict[name]\n    # This point should not be reached due to the check above\n    raise AttributeNotFoundError(name)\n</code></pre>"},{"location":"ref/model_project/#datadivr.project.model.NodeData.get_attributes_by_index","title":"<code>get_attributes_by_index(index)</code>","text":"<p>Get all attributes for a node by its index.</p> Source code in <code>datadivr/project/model.py</code> <pre><code>def get_attributes_by_index(self, index: int) -&gt; dict[str, Any]:\n    \"\"\"Get all attributes for a node by its index.\"\"\"\n    if index &lt; 0 or index &gt;= len(self.ids):\n        raise NodeIndexOutOfBoundsError(index, len(self.ids))\n\n    attributes = {}\n    for attr_dict in [self.str_attributes, self.float_attributes, self.int_attributes, self.bool_attributes]:\n        for name, values in attr_dict.items():\n            attributes[name] = values[index]\n    return attributes\n</code></pre>"},{"location":"ref/model_project/#datadivr.project.model.Project","title":"<code>Project</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Root model representing a DataDiVR project.</p> <p>This model contains all data necessary to represent and visualize a network of nodes, their connections, and various layouts using efficient data structures for large datasets.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Project display name</p> <code>attributes</code> <code>dict[str, str]</code> <p>Optional key-value pairs for project metadata</p> <code>nodes_data</code> <code>NodeData | None</code> <p>Efficient storage for node data (ids, names, and attributes)</p> <code>links_data</code> <code>LinkData | None</code> <p>Efficient storage for link data (start_ids, end_ids, and colors)</p> <code>layouts_data</code> <code>dict[str, LayoutData]</code> <p>Dictionary of layout configurations with efficient array storage</p> <code>selections</code> <code>list[Selection] | None</code> <p>Optional list of node Selection groups</p> Example <pre><code>project = Project(\n    name=\"My Project\",\n    attributes={},\n    nodes_data=NodeData(ids=np.array([1]), names=[\"Node 1\"], attributes={}),\n    links_data=None,\n    layouts_data={},\n    selections=[]\n)\n</code></pre> Source code in <code>datadivr/project/model.py</code> <pre><code>class Project(BaseModel):\n    \"\"\"Root model representing a DataDiVR project.\n\n    This model contains all data necessary to represent and visualize\n    a network of nodes, their connections, and various layouts using\n    efficient data structures for large datasets.\n\n    Attributes:\n        name: Project display name\n        attributes: Optional key-value pairs for project metadata\n        nodes_data: Efficient storage for node data (ids, names, and attributes)\n        links_data: Efficient storage for link data (start_ids, end_ids, and colors)\n        layouts_data: Dictionary of layout configurations with efficient array storage\n        selections: Optional list of node Selection groups\n\n    Example:\n        ```python\n        project = Project(\n            name=\"My Project\",\n            attributes={},\n            nodes_data=NodeData(ids=np.array([1]), names=[\"Node 1\"], attributes={}),\n            links_data=None,\n            layouts_data={},\n            selections=[]\n        )\n        ```\n    \"\"\"\n\n    model_config = {\n        \"arbitrary_types_allowed\": True,\n        \"json_schema_extra\": {\n            \"examples\": [\n                {\"name\": \"Example Project\", \"nodes\": [{\"id\": 1, \"name\": \"First Node\"}], \"links\": [], \"layouts\": []}\n            ]\n        },\n    }\n\n    name: str\n    attributes: dict[str, str] = Field(default_factory=dict, description=\"Custom metadata key-value pairs\")\n\n    # Change to public names\n    nodes_data: NodeData | None = None\n    links_data: LinkData | None = None\n    layouts_data: dict[str, LayoutData] = Field(default_factory=dict)\n    selections: list[Selection] | None = []\n\n    def add_nodes_bulk(self, ids: npt.NDArray[np.int32], attributes: dict[str, npt.NDArray]) -&gt; None:\n        \"\"\"Efficiently add multiple nodes at once with attribute arrays\n\n        Args:\n            ids: Array of node IDs\n            attributes: Dictionary mapping attribute names to numpy arrays of values\n        \"\"\"\n        self.nodes_data = NodeData(ids=ids)\n        for name, values in attributes.items():\n            self.nodes_data.add_attribute(name, values, values.dtype)\n\n    def add_layout_bulk(\n        self,\n        name: str,\n        node_ids: npt.NDArray[np.int32],\n        positions: npt.NDArray[np.float32],\n        colors: npt.NDArray[np.uint8],\n    ) -&gt; None:\n        \"\"\"Efficiently add layout data\"\"\"\n        self.layouts_data[name] = LayoutData(node_ids=node_ids, positions=positions, colors=colors)\n\n    def add_links_bulk(\n        self, start_ids: npt.NDArray[np.int32], end_ids: npt.NDArray[np.int32], colors: npt.NDArray[np.uint8]\n    ) -&gt; None:\n        \"\"\"Efficiently add multiple links at once\"\"\"\n        self.links_data = LinkData(start_ids=start_ids, end_ids=end_ids, colors=colors)\n\n    def model_dump(\n        self,\n        *,\n        mode: str = \"python\",\n        include: Any = None,\n        exclude: Any = None,\n        by_alias: bool = False,\n        exclude_unset: bool = False,\n        exclude_defaults: bool = False,\n        exclude_none: bool = False,\n        round_trip: bool = False,\n        warnings: bool | str = True,\n        serialize_as_any: bool = False,\n        context: Any = None,\n    ) -&gt; dict[str, Any]:\n        \"\"\"Custom serialization optimized for speed and memory efficiency\"\"\"\n        # Combine all attribute dictionaries\n        attributes = {}\n        if self.nodes_data:\n            attributes.update({str(k): v.tolist() for k, v in self.nodes_data.str_attributes.items()})\n            attributes.update({str(k): v.tolist() for k, v in self.nodes_data.float_attributes.items()})\n            attributes.update({str(k): v.tolist() for k, v in self.nodes_data.int_attributes.items()})\n            attributes.update({str(k): v.tolist() for k, v in self.nodes_data.bool_attributes.items()})\n\n        # Ensure all keys in attributes are strings\n        attributes = {str(k): v for k, v in attributes.items()}\n\n        return {\n            \"name\": self.name,\n            \"attributes\": self.attributes,\n            \"nodes\": {\n                \"ids\": self.nodes_data.ids.astype(int).tolist() if self.nodes_data else [],\n                \"attributes\": attributes,  # Use the updated attributes dictionary\n            },\n            \"links\": {\n                \"start_ids\": self.links_data.start_ids.astype(int).tolist() if self.links_data else [],\n                \"end_ids\": self.links_data.end_ids.astype(int).tolist() if self.links_data else [],\n                \"colors\": self.links_data.colors.tolist() if self.links_data else [],\n            },\n            \"layouts\": {\n                str(name): {  # Ensure layout names are strings\n                    \"node_ids\": layout.node_ids.astype(int).tolist(),\n                    \"positions\": layout.positions.tolist(),\n                    \"colors\": layout.colors.tolist(),\n                }\n                for name, layout in self.layouts_data.items()\n            },\n            \"selections\": [s.model_dump() for s in self.selections] if self.selections else [],\n        }\n\n    @classmethod\n    def model_validate(\n        cls,\n        obj: Any,\n        *,\n        strict: bool | None = None,\n        from_attributes: bool | None = None,\n        context: Any | None = None,\n    ) -&gt; \"Project\":\n        \"\"\"Custom deserialization from efficient storage\"\"\"\n        data = obj  # obj will contain our dictionary data\n        project = cls(name=data[\"name\"], attributes=data.get(\"attributes\", {}))\n\n        # Load nodes\n        if \"nodes\" in data:\n            project.nodes_data = NodeData(ids=np.array(data[\"nodes\"][\"ids\"], dtype=np.int32))\n\n            # Load attributes into appropriate typed dictionaries\n            if \"attributes\" in data[\"nodes\"]:\n                for name, values in data[\"nodes\"][\"attributes\"].items():\n                    # Convert to numpy array and infer type\n                    arr = np.array(values)\n                    project.nodes_data.add_attribute(name, arr, arr.dtype)\n\n        # Load links\n        if \"links\" in data:\n            project.links_data = LinkData(\n                start_ids=np.array(data[\"links\"][\"start_ids\"], dtype=np.int32),\n                end_ids=np.array(data[\"links\"][\"end_ids\"], dtype=np.int32),\n                colors=np.array(data[\"links\"][\"colors\"], dtype=np.uint8),\n            )\n\n        # Load layouts\n        if \"layouts\" in data:\n            for name, layout_data in data[\"layouts\"].items():\n                project.layouts_data[name] = LayoutData(\n                    node_ids=np.array(layout_data[\"node_ids\"], dtype=np.int32),\n                    positions=np.array(layout_data[\"positions\"], dtype=np.float32),\n                    colors=np.array(layout_data[\"colors\"], dtype=np.uint8),\n                )\n\n        # Load selections\n        if \"selections\" in data:\n            project.selections = [Selection.model_validate(s) for s in data[\"selections\"]]\n\n        return project\n\n    @classmethod\n    def load_from_json_file(cls, file_path: Path | str) -&gt; \"Project\":\n        \"\"\"Load a project from a JSON file.\n\n        Args:\n            file_path: Path to the JSON file\n\n        Returns:\n            Project: Loaded and validated Project instance\n\n        Raises:\n            ValidationError: If the JSON data doesn't match the expected schema\n            OSError: If there are file access issues\n        \"\"\"\n        file_path = Path(file_path)\n        logger.debug(\"Loading project\", file_path=str(file_path))\n\n        try:\n            with file_path.open(\"r\", encoding=\"utf-8\") as f:\n                data = json.load(f)\n                project = cls.model_validate(data)\n                logger.info(\"Project loaded successfully\", project_name=project.name)\n                return project\n        except Exception as e:\n            logger.exception(\"Failed to load project\", error=str(e))\n            raise\n\n    def save_to_json_file(self, file_path: Path | str) -&gt; None:\n        \"\"\"Save the project to a JSON file with optimized performance.\"\"\"\n        file_path = Path(file_path)\n        logger.debug(\"Saving project\", file_path=str(file_path))\n\n        try:\n            # Convert to JSON-compatible dict first\n            data = self.model_dump()\n\n            # Use a faster JSON encoder\n            import orjson  # Much faster than standard json\n\n            # Write in binary mode with orjson\n            with file_path.open(\"wb\") as f:\n                f.write(orjson.dumps(data, option=orjson.OPT_INDENT_2 | orjson.OPT_SERIALIZE_NUMPY))\n\n            logger.info(\"Project saved successfully\", project_name=self.name)\n        except Exception as e:\n            logger.exception(\"Failed to save project\", error=str(e))\n            raise\n\n    def save_to_binary_file(self, file_path: Path | str) -&gt; None:\n        \"\"\"Save the project using numpy binary format for large arrays.\"\"\"\n        file_path = Path(file_path)\n        logger.debug(\"Saving project in binary format\", file_path=str(file_path))\n\n        try:\n            with tempfile.TemporaryDirectory() as temp_dir:\n                temp_path = Path(temp_dir)\n                self._save_arrays_to_temp(temp_path)\n                self._save_metadata_to_temp(temp_path)\n                self._create_zip_archive(file_path, temp_path)\n                logger.info(\"Project saved successfully in binary format\", project_name=self.name)\n        except Exception as e:\n            logger.exception(\"Failed to save project in binary format\", error=str(e))\n            raise\n\n    def _save_arrays_to_temp(self, temp_path: Path) -&gt; None:\n        \"\"\"Save numpy arrays to temporary directory.\"\"\"\n        arrays_dir = temp_path / \"arrays\"\n        arrays_dir.mkdir()\n\n        # Save node data\n        if self.nodes_data:\n            np.save(arrays_dir / \"node_ids.npy\", self.nodes_data.ids)\n            self._save_node_attributes(arrays_dir)\n\n        # Save links\n        if self.links_data:\n            np.save(arrays_dir / \"link_start_ids.npy\", self.links_data.start_ids)\n            np.save(arrays_dir / \"link_end_ids.npy\", self.links_data.end_ids)\n            np.save(arrays_dir / \"link_colors.npy\", self.links_data.colors)\n\n        # Save layouts\n        for name, layout in self.layouts_data.items():\n            layout_dir = arrays_dir / f\"layout_{name}\"\n            layout_dir.mkdir()\n            np.save(layout_dir / \"node_ids.npy\", layout.node_ids)\n            np.save(layout_dir / \"positions.npy\", layout.positions)\n            np.save(layout_dir / \"colors.npy\", layout.colors)\n\n    def _save_node_attributes(self, arrays_dir: Path) -&gt; None:\n        \"\"\"Save node attributes to arrays directory.\"\"\"\n        if self.nodes_data is None:\n            return  # Exit early if nodes_data is None\n\n        for attr_dict in [\n            self.nodes_data.str_attributes,\n            self.nodes_data.float_attributes,\n            self.nodes_data.int_attributes,\n            self.nodes_data.bool_attributes,\n        ]:\n            for name, values in attr_dict.items():\n                np.save(arrays_dir / f\"node_attr_{name}.npy\", values)\n\n    def _save_metadata_to_temp(self, temp_path: Path) -&gt; None:\n        \"\"\"Save metadata JSON to temporary directory.\"\"\"\n        metadata = {\n            \"name\": self.name,\n            \"attributes\": self.attributes,\n            \"nodes\": {\n                \"attributes\": {\n                    name: str(values.dtype)\n                    for attr_dict in [\n                        self.nodes_data.str_attributes,\n                        self.nodes_data.float_attributes,\n                        self.nodes_data.int_attributes,\n                        self.nodes_data.bool_attributes,\n                    ]\n                    for name, values in attr_dict.items()\n                }\n                if self.nodes_data\n                else {}\n            },\n            \"layouts\": list(self.layouts_data.keys()),\n            \"selections\": [s.model_dump() for s in self.selections] if self.selections else [],\n        }\n\n        with open(temp_path / \"metadata.json\", \"wb\") as f:\n            f.write(orjson.dumps(metadata, option=orjson.OPT_INDENT_2))\n\n    def _create_zip_archive(self, file_path: Path, temp_path: Path) -&gt; None:\n        \"\"\"Create zip archive from temporary directory.\"\"\"\n        with ZipFile(file_path, \"w\", compression=ZIP_DEFLATED) as zf:\n            for file_path in temp_path.rglob(\"*\"):\n                if file_path.is_file():\n                    zf.write(file_path, file_path.relative_to(temp_path))\n\n    @classmethod\n    def load_from_binary_file(cls, file_path: Path | str) -&gt; \"Project\":\n        \"\"\"Load a project from a binary format file.\"\"\"\n        file_path = Path(file_path)\n        logger.debug(\"Loading project from binary format\", file_path=str(file_path))\n\n        try:\n            with tempfile.TemporaryDirectory() as temp_dir:\n                temp_path = Path(temp_dir)\n\n                # Extract zip archive\n                with ZipFile(file_path, \"r\") as zf:\n                    zf.extractall(temp_path)\n\n                # Load metadata\n                with open(temp_path / \"metadata.json\", \"rb\") as f:\n                    metadata = orjson.loads(f.read())\n\n                # Create project instance\n                project = cls(name=metadata[\"name\"], attributes=metadata.get(\"attributes\", {}))\n\n                # Load nodes\n                if (temp_path / \"arrays/node_ids.npy\").exists():\n                    node_ids = np.load(temp_path / \"arrays/node_ids.npy\")\n                    project.nodes_data = NodeData(ids=node_ids)\n\n                    # Load attributes from metadata\n                    if \"nodes\" in metadata and \"attributes\" in metadata[\"nodes\"]:\n                        for name, _dtype_info in metadata[\"nodes\"][\"attributes\"].items():\n                            attr_path = temp_path / f\"arrays/node_attr_{name}.npy\"\n                            if attr_path.exists():\n                                values = np.load(attr_path, allow_pickle=True)\n                                project.nodes_data.add_attribute(name, values, values.dtype)\n\n                # Load links if present\n                if (temp_path / \"arrays/link_start_ids.npy\").exists():\n                    project.links_data = LinkData(\n                        start_ids=np.load(temp_path / \"arrays/link_start_ids.npy\"),\n                        end_ids=np.load(temp_path / \"arrays/link_end_ids.npy\"),\n                        colors=np.load(temp_path / \"arrays/link_colors.npy\"),\n                    )\n\n                # Load layouts\n                for layout_name in metadata[\"layouts\"]:\n                    layout_dir = temp_path / f\"arrays/layout_{layout_name}\"\n                    project.layouts_data[layout_name] = LayoutData(\n                        node_ids=np.load(layout_dir / \"node_ids.npy\"),\n                        positions=np.load(layout_dir / \"positions.npy\"),\n                        colors=np.load(layout_dir / \"colors.npy\"),\n                    )\n\n                # Load selections\n                if \"selections\" in metadata:\n                    project.selections = [Selection.model_validate(s) for s in metadata[\"selections\"]]\n\n                return project\n\n        except Exception as e:\n            logger.exception(\"Failed to load project from binary format\", error=str(e))\n            raise\n\n    def get_layout_positions(self, layout_name: str = \"default\") -&gt; npt.NDArray[np.float32]:\n        \"\"\"Get node positions for a specific layout\"\"\"\n        if layout_name not in self.layouts_data:\n            raise LayoutNotFoundError(layout_name)\n        return self.layouts_data[layout_name].positions\n\n    def get_layout_colors(self, layout_name: str = \"default\") -&gt; npt.NDArray[np.uint8]:\n        \"\"\"Get node colors for a specific layout\"\"\"\n        if layout_name not in self.layouts_data:\n            raise LayoutNotFoundError(layout_name)\n        return self.layouts_data[layout_name].colors\n\n    def create_textures(self, output_dir: str = \"static/projects/\") -&gt; None:\n        \"\"\"Create textures for the project.\"\"\"\n        create_textures_from_project(\n            self.name,\n            self.layouts_data,\n            {\n                \"start_ids\": self.links_data.start_ids,\n                \"end_ids\": self.links_data.end_ids,\n                \"colors\": self.links_data.colors,\n            }\n            if self.links_data\n            else None,\n            output_dir,\n        )\n\n    def create_json_files(self, output_dir: str = \"static/projects/\") -&gt; None:\n        \"\"\"Create JSON files for nodes and links.\"\"\"\n        if self.nodes_data:\n            create_nodes_json(\n                self.nodes_data.ids.tolist(),  # Convert ndarray to list\n                [str(i) for i in self.nodes_data.ids],  # Assuming node names are string representations of IDs\n                self.name,\n                output_dir,\n            )\n\n        if self.links_data:\n            create_links_json(\n                list(zip(self.links_data.start_ids, self.links_data.end_ids, strict=False)), self.name, output_dir\n            )\n\n    def create_project_summary(self, output_dir: str = \"static/projects/\") -&gt; None:\n        \"\"\"Create a project summary JSON file.\"\"\"\n        project_summary = {\n            \"name\": self.name,\n            \"layouts\": list(self.layouts_data.keys()),\n            \"layoutsRGB\": [f\"{layout}RGB\" for layout in self.layouts_data],\n            \"links\": [\"links_XYZ\"],  # Placeholder, adjust as needed\n            \"linksRGB\": [\"links_RGB\"],  # Placeholder, adjust as needed\n            \"nodecount\": len(self.nodes_data.ids) if self.nodes_data else 0,\n            \"linkcount\": len(self.links_data.start_ids) if self.links_data else 0,\n            \"labelcount\": 0,  # Placeholder, adjust as needed\n            \"annotationTypes\": False,  # Placeholder, adjust as needed\n        }\n\n        file_path = Path(output_dir) / self.name / \"project.json\"\n        file_path.parent.mkdir(parents=True, exist_ok=True)\n\n        with file_path.open(\"w\", encoding=\"utf-8\") as f:\n            json.dump(project_summary, f, indent=4)\n\n        logger.info(f\"Project summary saved to {file_path}\")\n\n    def create_all_assets(self, output_dir: str = \"static/projects/\") -&gt; None:\n        \"\"\"Create all project assets including textures, JSON files, and project summary.\"\"\"\n        self.create_textures(output_dir)\n        self.create_json_files(output_dir)\n        self.create_project_summary(output_dir)\n        logger.info(\"All project assets created successfully\", project_name=self.name)\n</code></pre>"},{"location":"ref/model_project/#datadivr.project.model.Project-functions","title":"Functions","text":""},{"location":"ref/model_project/#datadivr.project.model.Project.add_layout_bulk","title":"<code>add_layout_bulk(name, node_ids, positions, colors)</code>","text":"<p>Efficiently add layout data</p> Source code in <code>datadivr/project/model.py</code> <pre><code>def add_layout_bulk(\n    self,\n    name: str,\n    node_ids: npt.NDArray[np.int32],\n    positions: npt.NDArray[np.float32],\n    colors: npt.NDArray[np.uint8],\n) -&gt; None:\n    \"\"\"Efficiently add layout data\"\"\"\n    self.layouts_data[name] = LayoutData(node_ids=node_ids, positions=positions, colors=colors)\n</code></pre>"},{"location":"ref/model_project/#datadivr.project.model.Project.add_links_bulk","title":"<code>add_links_bulk(start_ids, end_ids, colors)</code>","text":"<p>Efficiently add multiple links at once</p> Source code in <code>datadivr/project/model.py</code> <pre><code>def add_links_bulk(\n    self, start_ids: npt.NDArray[np.int32], end_ids: npt.NDArray[np.int32], colors: npt.NDArray[np.uint8]\n) -&gt; None:\n    \"\"\"Efficiently add multiple links at once\"\"\"\n    self.links_data = LinkData(start_ids=start_ids, end_ids=end_ids, colors=colors)\n</code></pre>"},{"location":"ref/model_project/#datadivr.project.model.Project.add_nodes_bulk","title":"<code>add_nodes_bulk(ids, attributes)</code>","text":"<p>Efficiently add multiple nodes at once with attribute arrays</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>NDArray[int32]</code> <p>Array of node IDs</p> required <code>attributes</code> <code>dict[str, NDArray]</code> <p>Dictionary mapping attribute names to numpy arrays of values</p> required Source code in <code>datadivr/project/model.py</code> <pre><code>def add_nodes_bulk(self, ids: npt.NDArray[np.int32], attributes: dict[str, npt.NDArray]) -&gt; None:\n    \"\"\"Efficiently add multiple nodes at once with attribute arrays\n\n    Args:\n        ids: Array of node IDs\n        attributes: Dictionary mapping attribute names to numpy arrays of values\n    \"\"\"\n    self.nodes_data = NodeData(ids=ids)\n    for name, values in attributes.items():\n        self.nodes_data.add_attribute(name, values, values.dtype)\n</code></pre>"},{"location":"ref/model_project/#datadivr.project.model.Project.create_all_assets","title":"<code>create_all_assets(output_dir='static/projects/')</code>","text":"<p>Create all project assets including textures, JSON files, and project summary.</p> Source code in <code>datadivr/project/model.py</code> <pre><code>def create_all_assets(self, output_dir: str = \"static/projects/\") -&gt; None:\n    \"\"\"Create all project assets including textures, JSON files, and project summary.\"\"\"\n    self.create_textures(output_dir)\n    self.create_json_files(output_dir)\n    self.create_project_summary(output_dir)\n    logger.info(\"All project assets created successfully\", project_name=self.name)\n</code></pre>"},{"location":"ref/model_project/#datadivr.project.model.Project.create_json_files","title":"<code>create_json_files(output_dir='static/projects/')</code>","text":"<p>Create JSON files for nodes and links.</p> Source code in <code>datadivr/project/model.py</code> <pre><code>def create_json_files(self, output_dir: str = \"static/projects/\") -&gt; None:\n    \"\"\"Create JSON files for nodes and links.\"\"\"\n    if self.nodes_data:\n        create_nodes_json(\n            self.nodes_data.ids.tolist(),  # Convert ndarray to list\n            [str(i) for i in self.nodes_data.ids],  # Assuming node names are string representations of IDs\n            self.name,\n            output_dir,\n        )\n\n    if self.links_data:\n        create_links_json(\n            list(zip(self.links_data.start_ids, self.links_data.end_ids, strict=False)), self.name, output_dir\n        )\n</code></pre>"},{"location":"ref/model_project/#datadivr.project.model.Project.create_project_summary","title":"<code>create_project_summary(output_dir='static/projects/')</code>","text":"<p>Create a project summary JSON file.</p> Source code in <code>datadivr/project/model.py</code> <pre><code>def create_project_summary(self, output_dir: str = \"static/projects/\") -&gt; None:\n    \"\"\"Create a project summary JSON file.\"\"\"\n    project_summary = {\n        \"name\": self.name,\n        \"layouts\": list(self.layouts_data.keys()),\n        \"layoutsRGB\": [f\"{layout}RGB\" for layout in self.layouts_data],\n        \"links\": [\"links_XYZ\"],  # Placeholder, adjust as needed\n        \"linksRGB\": [\"links_RGB\"],  # Placeholder, adjust as needed\n        \"nodecount\": len(self.nodes_data.ids) if self.nodes_data else 0,\n        \"linkcount\": len(self.links_data.start_ids) if self.links_data else 0,\n        \"labelcount\": 0,  # Placeholder, adjust as needed\n        \"annotationTypes\": False,  # Placeholder, adjust as needed\n    }\n\n    file_path = Path(output_dir) / self.name / \"project.json\"\n    file_path.parent.mkdir(parents=True, exist_ok=True)\n\n    with file_path.open(\"w\", encoding=\"utf-8\") as f:\n        json.dump(project_summary, f, indent=4)\n\n    logger.info(f\"Project summary saved to {file_path}\")\n</code></pre>"},{"location":"ref/model_project/#datadivr.project.model.Project.create_textures","title":"<code>create_textures(output_dir='static/projects/')</code>","text":"<p>Create textures for the project.</p> Source code in <code>datadivr/project/model.py</code> <pre><code>def create_textures(self, output_dir: str = \"static/projects/\") -&gt; None:\n    \"\"\"Create textures for the project.\"\"\"\n    create_textures_from_project(\n        self.name,\n        self.layouts_data,\n        {\n            \"start_ids\": self.links_data.start_ids,\n            \"end_ids\": self.links_data.end_ids,\n            \"colors\": self.links_data.colors,\n        }\n        if self.links_data\n        else None,\n        output_dir,\n    )\n</code></pre>"},{"location":"ref/model_project/#datadivr.project.model.Project.get_layout_colors","title":"<code>get_layout_colors(layout_name='default')</code>","text":"<p>Get node colors for a specific layout</p> Source code in <code>datadivr/project/model.py</code> <pre><code>def get_layout_colors(self, layout_name: str = \"default\") -&gt; npt.NDArray[np.uint8]:\n    \"\"\"Get node colors for a specific layout\"\"\"\n    if layout_name not in self.layouts_data:\n        raise LayoutNotFoundError(layout_name)\n    return self.layouts_data[layout_name].colors\n</code></pre>"},{"location":"ref/model_project/#datadivr.project.model.Project.get_layout_positions","title":"<code>get_layout_positions(layout_name='default')</code>","text":"<p>Get node positions for a specific layout</p> Source code in <code>datadivr/project/model.py</code> <pre><code>def get_layout_positions(self, layout_name: str = \"default\") -&gt; npt.NDArray[np.float32]:\n    \"\"\"Get node positions for a specific layout\"\"\"\n    if layout_name not in self.layouts_data:\n        raise LayoutNotFoundError(layout_name)\n    return self.layouts_data[layout_name].positions\n</code></pre>"},{"location":"ref/model_project/#datadivr.project.model.Project.load_from_binary_file","title":"<code>load_from_binary_file(file_path)</code>  <code>classmethod</code>","text":"<p>Load a project from a binary format file.</p> Source code in <code>datadivr/project/model.py</code> <pre><code>@classmethod\ndef load_from_binary_file(cls, file_path: Path | str) -&gt; \"Project\":\n    \"\"\"Load a project from a binary format file.\"\"\"\n    file_path = Path(file_path)\n    logger.debug(\"Loading project from binary format\", file_path=str(file_path))\n\n    try:\n        with tempfile.TemporaryDirectory() as temp_dir:\n            temp_path = Path(temp_dir)\n\n            # Extract zip archive\n            with ZipFile(file_path, \"r\") as zf:\n                zf.extractall(temp_path)\n\n            # Load metadata\n            with open(temp_path / \"metadata.json\", \"rb\") as f:\n                metadata = orjson.loads(f.read())\n\n            # Create project instance\n            project = cls(name=metadata[\"name\"], attributes=metadata.get(\"attributes\", {}))\n\n            # Load nodes\n            if (temp_path / \"arrays/node_ids.npy\").exists():\n                node_ids = np.load(temp_path / \"arrays/node_ids.npy\")\n                project.nodes_data = NodeData(ids=node_ids)\n\n                # Load attributes from metadata\n                if \"nodes\" in metadata and \"attributes\" in metadata[\"nodes\"]:\n                    for name, _dtype_info in metadata[\"nodes\"][\"attributes\"].items():\n                        attr_path = temp_path / f\"arrays/node_attr_{name}.npy\"\n                        if attr_path.exists():\n                            values = np.load(attr_path, allow_pickle=True)\n                            project.nodes_data.add_attribute(name, values, values.dtype)\n\n            # Load links if present\n            if (temp_path / \"arrays/link_start_ids.npy\").exists():\n                project.links_data = LinkData(\n                    start_ids=np.load(temp_path / \"arrays/link_start_ids.npy\"),\n                    end_ids=np.load(temp_path / \"arrays/link_end_ids.npy\"),\n                    colors=np.load(temp_path / \"arrays/link_colors.npy\"),\n                )\n\n            # Load layouts\n            for layout_name in metadata[\"layouts\"]:\n                layout_dir = temp_path / f\"arrays/layout_{layout_name}\"\n                project.layouts_data[layout_name] = LayoutData(\n                    node_ids=np.load(layout_dir / \"node_ids.npy\"),\n                    positions=np.load(layout_dir / \"positions.npy\"),\n                    colors=np.load(layout_dir / \"colors.npy\"),\n                )\n\n            # Load selections\n            if \"selections\" in metadata:\n                project.selections = [Selection.model_validate(s) for s in metadata[\"selections\"]]\n\n            return project\n\n    except Exception as e:\n        logger.exception(\"Failed to load project from binary format\", error=str(e))\n        raise\n</code></pre>"},{"location":"ref/model_project/#datadivr.project.model.Project.load_from_json_file","title":"<code>load_from_json_file(file_path)</code>  <code>classmethod</code>","text":"<p>Load a project from a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path | str</code> <p>Path to the JSON file</p> required <p>Returns:</p> Name Type Description <code>Project</code> <code>Project</code> <p>Loaded and validated Project instance</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If the JSON data doesn't match the expected schema</p> <code>OSError</code> <p>If there are file access issues</p> Source code in <code>datadivr/project/model.py</code> <pre><code>@classmethod\ndef load_from_json_file(cls, file_path: Path | str) -&gt; \"Project\":\n    \"\"\"Load a project from a JSON file.\n\n    Args:\n        file_path: Path to the JSON file\n\n    Returns:\n        Project: Loaded and validated Project instance\n\n    Raises:\n        ValidationError: If the JSON data doesn't match the expected schema\n        OSError: If there are file access issues\n    \"\"\"\n    file_path = Path(file_path)\n    logger.debug(\"Loading project\", file_path=str(file_path))\n\n    try:\n        with file_path.open(\"r\", encoding=\"utf-8\") as f:\n            data = json.load(f)\n            project = cls.model_validate(data)\n            logger.info(\"Project loaded successfully\", project_name=project.name)\n            return project\n    except Exception as e:\n        logger.exception(\"Failed to load project\", error=str(e))\n        raise\n</code></pre>"},{"location":"ref/model_project/#datadivr.project.model.Project.model_dump","title":"<code>model_dump(*, mode='python', include=None, exclude=None, by_alias=False, exclude_unset=False, exclude_defaults=False, exclude_none=False, round_trip=False, warnings=True, serialize_as_any=False, context=None)</code>","text":"<p>Custom serialization optimized for speed and memory efficiency</p> Source code in <code>datadivr/project/model.py</code> <pre><code>def model_dump(\n    self,\n    *,\n    mode: str = \"python\",\n    include: Any = None,\n    exclude: Any = None,\n    by_alias: bool = False,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    round_trip: bool = False,\n    warnings: bool | str = True,\n    serialize_as_any: bool = False,\n    context: Any = None,\n) -&gt; dict[str, Any]:\n    \"\"\"Custom serialization optimized for speed and memory efficiency\"\"\"\n    # Combine all attribute dictionaries\n    attributes = {}\n    if self.nodes_data:\n        attributes.update({str(k): v.tolist() for k, v in self.nodes_data.str_attributes.items()})\n        attributes.update({str(k): v.tolist() for k, v in self.nodes_data.float_attributes.items()})\n        attributes.update({str(k): v.tolist() for k, v in self.nodes_data.int_attributes.items()})\n        attributes.update({str(k): v.tolist() for k, v in self.nodes_data.bool_attributes.items()})\n\n    # Ensure all keys in attributes are strings\n    attributes = {str(k): v for k, v in attributes.items()}\n\n    return {\n        \"name\": self.name,\n        \"attributes\": self.attributes,\n        \"nodes\": {\n            \"ids\": self.nodes_data.ids.astype(int).tolist() if self.nodes_data else [],\n            \"attributes\": attributes,  # Use the updated attributes dictionary\n        },\n        \"links\": {\n            \"start_ids\": self.links_data.start_ids.astype(int).tolist() if self.links_data else [],\n            \"end_ids\": self.links_data.end_ids.astype(int).tolist() if self.links_data else [],\n            \"colors\": self.links_data.colors.tolist() if self.links_data else [],\n        },\n        \"layouts\": {\n            str(name): {  # Ensure layout names are strings\n                \"node_ids\": layout.node_ids.astype(int).tolist(),\n                \"positions\": layout.positions.tolist(),\n                \"colors\": layout.colors.tolist(),\n            }\n            for name, layout in self.layouts_data.items()\n        },\n        \"selections\": [s.model_dump() for s in self.selections] if self.selections else [],\n    }\n</code></pre>"},{"location":"ref/model_project/#datadivr.project.model.Project.model_validate","title":"<code>model_validate(obj, *, strict=None, from_attributes=None, context=None)</code>  <code>classmethod</code>","text":"<p>Custom deserialization from efficient storage</p> Source code in <code>datadivr/project/model.py</code> <pre><code>@classmethod\ndef model_validate(\n    cls,\n    obj: Any,\n    *,\n    strict: bool | None = None,\n    from_attributes: bool | None = None,\n    context: Any | None = None,\n) -&gt; \"Project\":\n    \"\"\"Custom deserialization from efficient storage\"\"\"\n    data = obj  # obj will contain our dictionary data\n    project = cls(name=data[\"name\"], attributes=data.get(\"attributes\", {}))\n\n    # Load nodes\n    if \"nodes\" in data:\n        project.nodes_data = NodeData(ids=np.array(data[\"nodes\"][\"ids\"], dtype=np.int32))\n\n        # Load attributes into appropriate typed dictionaries\n        if \"attributes\" in data[\"nodes\"]:\n            for name, values in data[\"nodes\"][\"attributes\"].items():\n                # Convert to numpy array and infer type\n                arr = np.array(values)\n                project.nodes_data.add_attribute(name, arr, arr.dtype)\n\n    # Load links\n    if \"links\" in data:\n        project.links_data = LinkData(\n            start_ids=np.array(data[\"links\"][\"start_ids\"], dtype=np.int32),\n            end_ids=np.array(data[\"links\"][\"end_ids\"], dtype=np.int32),\n            colors=np.array(data[\"links\"][\"colors\"], dtype=np.uint8),\n        )\n\n    # Load layouts\n    if \"layouts\" in data:\n        for name, layout_data in data[\"layouts\"].items():\n            project.layouts_data[name] = LayoutData(\n                node_ids=np.array(layout_data[\"node_ids\"], dtype=np.int32),\n                positions=np.array(layout_data[\"positions\"], dtype=np.float32),\n                colors=np.array(layout_data[\"colors\"], dtype=np.uint8),\n            )\n\n    # Load selections\n    if \"selections\" in data:\n        project.selections = [Selection.model_validate(s) for s in data[\"selections\"]]\n\n    return project\n</code></pre>"},{"location":"ref/model_project/#datadivr.project.model.Project.save_to_binary_file","title":"<code>save_to_binary_file(file_path)</code>","text":"<p>Save the project using numpy binary format for large arrays.</p> Source code in <code>datadivr/project/model.py</code> <pre><code>def save_to_binary_file(self, file_path: Path | str) -&gt; None:\n    \"\"\"Save the project using numpy binary format for large arrays.\"\"\"\n    file_path = Path(file_path)\n    logger.debug(\"Saving project in binary format\", file_path=str(file_path))\n\n    try:\n        with tempfile.TemporaryDirectory() as temp_dir:\n            temp_path = Path(temp_dir)\n            self._save_arrays_to_temp(temp_path)\n            self._save_metadata_to_temp(temp_path)\n            self._create_zip_archive(file_path, temp_path)\n            logger.info(\"Project saved successfully in binary format\", project_name=self.name)\n    except Exception as e:\n        logger.exception(\"Failed to save project in binary format\", error=str(e))\n        raise\n</code></pre>"},{"location":"ref/model_project/#datadivr.project.model.Project.save_to_json_file","title":"<code>save_to_json_file(file_path)</code>","text":"<p>Save the project to a JSON file with optimized performance.</p> Source code in <code>datadivr/project/model.py</code> <pre><code>def save_to_json_file(self, file_path: Path | str) -&gt; None:\n    \"\"\"Save the project to a JSON file with optimized performance.\"\"\"\n    file_path = Path(file_path)\n    logger.debug(\"Saving project\", file_path=str(file_path))\n\n    try:\n        # Convert to JSON-compatible dict first\n        data = self.model_dump()\n\n        # Use a faster JSON encoder\n        import orjson  # Much faster than standard json\n\n        # Write in binary mode with orjson\n        with file_path.open(\"wb\") as f:\n            f.write(orjson.dumps(data, option=orjson.OPT_INDENT_2 | orjson.OPT_SERIALIZE_NUMPY))\n\n        logger.info(\"Project saved successfully\", project_name=self.name)\n    except Exception as e:\n        logger.exception(\"Failed to save project\", error=str(e))\n        raise\n</code></pre>"},{"location":"ref/model_project/#datadivr.project.model-functions","title":"Functions","text":""},{"location":"ref/model_websocketmessage/","title":"Models","text":""},{"location":"ref/model_websocketmessage/#websocket-message","title":"WebSocket Message","text":"<p>options: show_root_heading: true show_source: true</p>"},{"location":"ref/model_websocketmessage/#datadivr.transport.models.WebSocketMessage","title":"<code>datadivr.transport.models.WebSocketMessage</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A model representing a WebSocket message.</p> <p>This model defines the structure of messages sent between WebSocket clients and servers. It includes fields for event identification, payload data, routing information, and optional text messages.</p> <p>Attributes:</p> Name Type Description <code>event_name</code> <code>str</code> <p>The name of the event this message represents</p> <code>payload</code> <code>Any | None</code> <p>Optional data associated with the message</p> <code>to</code> <code>str</code> <p>The recipient identifier (defaults to \"others\")</p> <code>from_id</code> <code>str</code> <p>The sender identifier (defaults to \"server\")</p> <code>message</code> <code>str | None</code> <p>Optional text message content</p> <code>websocket</code> <code>WebSocket | None</code> <p>Optional WebSocket reference</p> Example <pre><code>message = WebSocketMessage(\n    event_name=\"data_update\",\n    payload={\"value\": 42},\n    to=\"client_123\",\n    from_id=\"server\",\n    message=\"Updated data value\"\n)\n</code></pre> Source code in <code>datadivr/transport/models.py</code> <pre><code>class WebSocketMessage(BaseModel):\n    \"\"\"A model representing a WebSocket message.\n\n    This model defines the structure of messages sent between WebSocket clients and servers.\n    It includes fields for event identification, payload data, routing information, and optional\n    text messages.\n\n    Attributes:\n        event_name: The name of the event this message represents\n        payload: Optional data associated with the message\n        to: The recipient identifier (defaults to \"others\")\n        from_id: The sender identifier (defaults to \"server\")\n        message: Optional text message content\n        websocket: Optional WebSocket reference\n\n    Example:\n        ```python\n        message = WebSocketMessage(\n            event_name=\"data_update\",\n            payload={\"value\": 42},\n            to=\"client_123\",\n            from_id=\"server\",\n            message=\"Updated data value\"\n        )\n        ```\n    \"\"\"\n\n    event_name: str\n    payload: Any | None = None\n    to: str = Field(default=\"others\")\n    from_id: str = Field(default=\"server\")\n    message: str | None = None\n    websocket: WebSocket | None = Field(default=None, exclude=True)\n\n    model_config = ConfigDict(\n        arbitrary_types_allowed=True,  # Allow WebSocket type\n        populate_by_name=True,\n        json_schema_extra={\n            \"example\": {\n                \"event_name\": \"sum_event\",\n                \"payload\": {\"numbers\": [1, 2, 3]},\n                \"to\": \"all\",\n                \"from\": \"client1\",\n                \"message\": \"Calculate sum\",\n            }\n        },\n    )\n</code></pre>"},{"location":"ref/server/","title":"WebSocket Server","text":"<p>The datadivr server provides a FastAPI-based WebSocket server that handles client connections, message routing, and event handling.</p>"},{"location":"ref/server/#basic-usage","title":"Basic Usage","text":"<pre><code>import uvicorn\nfrom datadivr import app, HandlerType, websocket_handler, WebSocketMessage\nfrom datadivr.transport.messages import create_error_message\n\n# Define handlers\n@websocket_handler(\"sum_event\", HandlerType.SERVER)\nasync def sum_handler(message: WebSocketMessage) -&gt; WebSocketMessage:\n    \"\"\"Calculate sum of numbers in the payload.\"\"\"\n    try:\n        numbers = message.payload.get(\"numbers\")\n        if not isinstance(numbers, list):\n            return create_error_message(\n                \"Payload must contain a list of numbers\",\n                message.from_id\n            )\n\n        result = sum(float(n) for n in numbers)\n        return WebSocketMessage(\n            event_name=\"sum_handler_result\",\n            payload=result,\n            to=message.from_id,\n        )\n    except Exception as e:\n        return create_error_message(f\"Error: {e}\", message.from_id)\n\n# Start the server\nif __name__ == \"__main__\":\n    uvicorn.run(app, host=\"127.0.0.1\", port=8765)\n</code></pre>"},{"location":"ref/server/#built-in-handlers","title":"Built-in Handlers","text":"<p>The server comes with built-in handlers for common operations:</p>"},{"location":"ref/server/#sum-handler","title":"Sum Handler","text":"<pre><code>@websocket_handler(\"sum_event\", HandlerType.SERVER)\nasync def sum_handler(message: WebSocketMessage) -&gt; WebSocketMessage:\n    \"\"\"Calculate sum of numbers in the payload.\"\"\"\n    try:\n        numbers = message.payload.get(\"numbers\")\n        result = sum(float(n) for n in numbers)\n        return WebSocketMessage(\n            event_name=\"sum_handler_result\",\n            payload=result,\n            to=message.from_id,\n        )\n    except Exception as e:\n        return create_error_message(f\"Error: {e}\", message.from_id)\n</code></pre>"},{"location":"ref/server/#server-implementation","title":"Server Implementation","text":"<p>The server uses FastAPI and maintains a registry of connected clients:</p> <pre><code># Module-level state\nclients: dict[WebSocket, str] = {}\n\n@app.websocket(\"/ws\")\nasync def websocket_endpoint(websocket: WebSocket) -&gt; None:\n    \"\"\"Handle incoming WebSocket connections.\"\"\"\n    await handle_connection(websocket)\n\nasync def handle_connection(websocket: WebSocket) -&gt; None:\n    \"\"\"Manage client connection lifecycle.\"\"\"\n    await websocket.accept()\n    client_id = str(uuid.uuid4())\n    clients[websocket] = client_id\n\n    try:\n        while True:\n            data = await websocket.receive_json()\n            message = WebSocketMessage.model_validate(data)\n            message.from_id = client_id\n            response = await handle_msg(message)\n            if response is not None:\n                await broadcast(response, websocket)\n    except WebSocketDisconnect:\n        del clients[websocket]\n</code></pre>"},{"location":"ref/server/#message-broadcasting","title":"Message Broadcasting","text":"<p>The server supports three broadcasting modes:</p> <ol> <li>All Clients:</li> </ol> <pre><code>message = WebSocketMessage(\n    event_name=\"announcement\",\n    message=\"Server maintenance in 5 minutes\",\n    to=\"all\"\n)\n</code></pre> <ol> <li>Other Clients:</li> </ol> <pre><code>message = WebSocketMessage(\n    event_name=\"user_joined\",\n    message=\"New user connected\",\n    to=\"others\"\n)\n</code></pre> <ol> <li>Specific Client:</li> </ol> <pre><code>message = WebSocketMessage(\n    event_name=\"private_message\",\n    message=\"Your request was processed\",\n    to=\"client_123\"\n)\n</code></pre>"},{"location":"ref/server/#error-handling","title":"Error Handling","text":"<p>The server handles various error conditions:</p> <ul> <li>Invalid message formats</li> <li>Client disconnections</li> <li>Message broadcasting failures</li> </ul> <p>All errors are logged using structured logging via <code>structlog</code>:</p> <pre><code>try:\n    message = WebSocketMessage.model_validate(data)\nexcept ValueError as e:\n    logger.exception(\"invalid_message_format\",\n                    error=str(e),\n                    client_id=client_id)\n    raise InvalidMessageFormat()\n</code></pre>"},{"location":"ref/server/#reference","title":"Reference","text":"<p>options: show_root_heading: true show_source: true</p>"},{"location":"ref/server/#datadivr.transport.server","title":"<code>datadivr.transport.server</code>","text":"<p>WebSocket server implementation for datadivr.</p> <p>This module provides a FastAPI-based WebSocket server that handles client connections, message routing, and event handling.</p> Example <pre><code>import uvicorn\nfrom datadivr import app\n\nuvicorn.run(app, host=\"127.0.0.1\", port=8765)\n</code></pre>"},{"location":"ref/server/#datadivr.transport.server-classes","title":"Classes","text":""},{"location":"ref/server/#datadivr.transport.server-functions","title":"Functions","text":""},{"location":"ref/server/#datadivr.transport.server.add_client","title":"<code>add_client(websocket)</code>","text":"<p>Add a new client and return its client ID.</p> Source code in <code>datadivr/transport/server.py</code> <pre><code>def add_client(websocket: WebSocket) -&gt; str:\n    \"\"\"Add a new client and return its client ID.\"\"\"\n    client_id = str(uuid.uuid4())\n    clients[client_id] = {\"websocket\": websocket, \"state\": {}}\n    logger.info(\"client_connected\", client_id=client_id, connected_clients=len(clients))\n    return client_id\n</code></pre>"},{"location":"ref/server/#datadivr.transport.server.broadcast","title":"<code>broadcast(message, sender)</code>  <code>async</code>","text":"<p>Broadcast a message to appropriate clients.</p> Source code in <code>datadivr/transport/server.py</code> <pre><code>async def broadcast(message: WebSocketMessage, sender: WebSocket) -&gt; None:\n    \"\"\"Broadcast a message to appropriate clients.\"\"\"\n    message_data = message.model_dump()\n    targets: list[WebSocket] = []\n\n    if message.to == \"all\":\n        targets = [data[\"websocket\"] for data in clients.values()]\n    elif message.to == \"others\":\n        targets = [data[\"websocket\"] for cid, data in clients.items() if data[\"websocket\"] != sender]\n    else:\n        target_data = next((data for cid, data in clients.items() if cid == message.to), None)\n        if target_data:\n            targets = [target_data[\"websocket\"]]\n\n    logger.debug(\"broadcasting_message\", message=message_data, num_targets=len(targets))\n\n    for websocket in targets:\n        try:\n            # Find client_id for this websocket\n            client_id = next(cid for cid, data in clients.items() if data[\"websocket\"] == websocket)\n            await websocket.send_json(message_data)\n            logger.debug(\"message_sent\", client_id=client_id)\n        except Exception as e:\n            # Find client_id for this websocket\n            client_id = next(cid for cid, data in clients.items() if data[\"websocket\"] == websocket)\n            logger.exception(\"broadcast_error\", error=str(e), client_id=client_id)\n</code></pre>"},{"location":"ref/server/#datadivr.transport.server.close_client_connection","title":"<code>close_client_connection(client_id)</code>  <code>async</code>","text":"<p>Close a client connection.</p> Source code in <code>datadivr/transport/server.py</code> <pre><code>async def close_client_connection(client_id: str) -&gt; None:\n    \"\"\"Close a client connection.\"\"\"\n    if client_id in clients:\n        del clients[client_id]\n</code></pre>"},{"location":"ref/server/#datadivr.transport.server.get_client_state","title":"<code>get_client_state(client_id)</code>","text":"<p>Retrieve the state information for a client by client ID.</p> Source code in <code>datadivr/transport/server.py</code> <pre><code>def get_client_state(client_id: str) -&gt; dict[str, Any] | None:\n    \"\"\"Retrieve the state information for a client by client ID.\"\"\"\n    return clients.get(client_id, {}).get(\"state\")\n</code></pre>"},{"location":"ref/server/#datadivr.transport.server.handle_connection","title":"<code>handle_connection(websocket)</code>  <code>async</code>","text":"<p>Handle a WebSocket connection lifecycle.</p> Source code in <code>datadivr/transport/server.py</code> <pre><code>@BackgroundTasks.task()\nasync def handle_connection(websocket: WebSocket) -&gt; None:\n    \"\"\"Handle a WebSocket connection lifecycle.\"\"\"\n    await websocket.accept()\n    client_id = add_client(websocket)\n\n    try:\n        while True:\n            data = await websocket.receive_json()\n            try:\n                message = WebSocketMessage.model_validate(data)\n                message.from_id = client_id\n                response = await handle_msg(message)\n                if response is not None:\n                    await broadcast(response, websocket)\n            except ValueError as e:\n                logger.exception(\"invalid_message_format\", error=str(e), client_id=client_id)\n                raise InvalidMessageFormat() from None\n    except WebSocketDisconnect:\n        remove_client(client_id)\n    except Exception as e:\n        logger.exception(\"websocket_error\", error=str(e), client_id=client_id)\n        raise\n</code></pre>"},{"location":"ref/server/#datadivr.transport.server.handle_msg","title":"<code>handle_msg(message)</code>  <code>async</code>","text":"<p>Handle an incoming WebSocket message.</p> Source code in <code>datadivr/transport/server.py</code> <pre><code>async def handle_msg(message: WebSocketMessage) -&gt; WebSocketMessage | None:\n    \"\"\"Handle an incoming WebSocket message.\"\"\"\n    logger.debug(\"message_received\", message=message.model_dump())\n\n    handlers = get_handlers(HandlerType.SERVER)\n    if message.event_name in handlers:\n        logger.info(\"handling_event\", event_name=message.event_name)\n        return await handlers[message.event_name](message)\n    return message\n</code></pre>"},{"location":"ref/server/#datadivr.transport.server.lifespan","title":"<code>lifespan(app)</code>  <code>async</code>","text":"<p>Handle startup and shutdown events.</p> Source code in <code>datadivr/transport/server.py</code> <pre><code>@asynccontextmanager\nasync def lifespan(app: FastAPI) -&gt; AsyncIterator[None]:\n    \"\"\"Handle startup and shutdown events.\"\"\"\n    logger.debug(\"startup_initiated\")\n\n    server_handlers = get_handlers(HandlerType.SERVER)\n    logger.info(\"registered_server_handlers\", handlers=list(server_handlers.keys()))\n\n    await BackgroundTasks.start_all()\n    try:\n        yield\n    finally:\n        logger.debug(\"shutdown_initiated\", num_clients=len(clients))\n\n        for client_id in list(clients.keys()):\n            try:\n                await close_client_connection(client_id)\n                logger.debug(\"closed_client_connection\", client_id=client_id)\n            except Exception as e:\n                logger.exception(\"client_close_error\", error=str(e), client_id=client_id)\n\n        await BackgroundTasks.stop_all()\n        clients.clear()\n        logger.debug(\"shutdown_completed\")\n</code></pre>"},{"location":"ref/server/#datadivr.transport.server.remove_client","title":"<code>remove_client(client_id)</code>","text":"<p>Remove a client by its ID.</p> Source code in <code>datadivr/transport/server.py</code> <pre><code>def remove_client(client_id: str) -&gt; None:\n    \"\"\"Remove a client by its ID.\"\"\"\n    if client_id in clients:\n        del clients[client_id]\n        logger.info(\"client_disconnected\", client_id=client_id)\n</code></pre>"},{"location":"ref/server/#datadivr.transport.server.update_client_state","title":"<code>update_client_state(client_id, **kwargs)</code>","text":"<p>Update the state information for a client.</p> Source code in <code>datadivr/transport/server.py</code> <pre><code>def update_client_state(client_id: str, **kwargs: Any) -&gt; None:\n    \"\"\"Update the state information for a client.\"\"\"\n    if client_id in clients:\n        clients[client_id][\"state\"].update(kwargs)\n</code></pre>"},{"location":"ref/server/#datadivr.transport.server.websocket_endpoint","title":"<code>websocket_endpoint(websocket)</code>  <code>async</code>","text":"<p>Handle incoming WebSocket connections.</p> Source code in <code>datadivr/transport/server.py</code> <pre><code>@app.websocket(\"/ws\")\nasync def websocket_endpoint(websocket: WebSocket) -&gt; None:\n    \"\"\"Handle incoming WebSocket connections.\"\"\"\n    await BackgroundTasks.task(name=f\"ws_connection_{id(websocket)}\")(handle_connection)(websocket)\n</code></pre>"},{"location":"ref/transport/","title":"Transport","text":"<p>For details about the transport layer, see the Server and Client reference pages.</p>"},{"location":"ref/transport/#messages","title":"Messages","text":"<p>options: show_root_heading: true show_source: true</p>"},{"location":"ref/transport/#datadivr.transport.messages","title":"<code>datadivr.transport.messages</code>","text":""},{"location":"ref/transport/#datadivr.transport.messages-classes","title":"Classes","text":""},{"location":"ref/transport/#datadivr.transport.messages-functions","title":"Functions","text":""},{"location":"ref/transport/#datadivr.transport.messages.create_error_message","title":"<code>create_error_message(error_msg, to, websocket=None)</code>","text":"<p>Create a standardized error message.</p> Source code in <code>datadivr/transport/messages.py</code> <pre><code>def create_error_message(error_msg: str, to: str, websocket: WebSocket | None = None) -&gt; WebSocketMessage:\n    \"\"\"Create a standardized error message.\"\"\"\n    return WebSocketMessage(event_name=\"error\", message=error_msg, to=to, websocket=websocket)\n</code></pre>"},{"location":"ref/transport/#datadivr.transport.messages.create_message","title":"<code>create_message(event_name, payload, to, message=None, websocket=None)</code>","text":"<p>Create a standardized WebSocket message.</p> Source code in <code>datadivr/transport/messages.py</code> <pre><code>def create_message(\n    event_name: str, payload: Any, to: str, message: str | None = None, websocket: WebSocket | None = None\n) -&gt; WebSocketMessage:\n    \"\"\"Create a standardized WebSocket message.\"\"\"\n    return WebSocketMessage(event_name=event_name, payload=payload, to=to, message=message, websocket=websocket)\n</code></pre>"},{"location":"ref/transport/#datadivr.transport.messages.send_message","title":"<code>send_message(websocket, message)</code>  <code>async</code>","text":"<p>Send a message over a WebSocket connection.</p> Source code in <code>datadivr/transport/messages.py</code> <pre><code>@BackgroundTasks.task(name=\"send_message\")\nasync def send_message(websocket: Any, message: WebSocketMessage) -&gt; None:\n    \"\"\"Send a message over a WebSocket connection.\"\"\"\n    message_data = message.model_dump(exclude={\"websocket\"})\n    logger.debug(\"send_message\", message=message_data)\n\n    # Check if it's a FastAPI WebSocket\n    if hasattr(websocket, \"send_json\"):\n        await websocket.send_json(message_data)\n    # Check if it's a websockets WebSocket\n    elif hasattr(websocket, \"send\"):\n        await websocket.send(json.dumps(message_data))\n    else:\n        raise UnsupportedWebSocketTypeError()\n</code></pre>"}]}